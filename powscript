#!/bin/bash

set -E

PowscriptSourceDirectory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# powscript_source
#
# include source relatively from the powscript source code directory

powscript_source() {
  source "$PowscriptSourceDirectory/$1"
}


# printf_seq $start $end $format
#
# calls printf on each element of $(seq $start $end)
# the specifier %N is used to reference the current number.

printf_seq() {
  local start="$1" end="$2" format="$3"
  for n in $(seq $start $end); do
    printf "${format//%N/$n}"
  done
}


# setvar $varname $value
#
# dynamic variable assignation

setvar() {
  if [ -n "$1" ]; then
    printf -v "$1" '%s' "$2"
  else
    echo "$2"
  fi
}

# noshadow name ${argnumber:-0} ${varnumber:-1}
#
# wrap the function so that the name of the out variables
# (assumed to be the last arguments) do not conflict
# with the local variables declared within the function.
#
# Passing @ instead of a number means the number of arguments
# is variable. You may have a argnumber or varnumber be @, but
# not both.

ClearShadowingCounter=0

noshadow() {
  local name="$1"
  local argnumber="${2:-0}"
  local varnumber="${3:-1}"
  local arguments set_variables intermediary_variables intermediary_definition
  local prefix="__noshadow_${ClearShadowingCounter}_"

  case $argnumber in
    '@')
      arguments="\"\${@:1:\$((\$# - $varnumber))}\""

      set_variables="shift \$((\$# - $varnumber))
        $(printf_seq 1 $varnumber\
          "setvar \"\$%N\" \"\$$prefix%N\"\n")"

      intermediary_variables="$(printf_seq 1 $varnumber "$prefix%N")"
      intermediary_definition="local $intermediary_variables"
      ;;
    *)
      arguments="$(printf_seq 1 $argnumber '"$%N" ')"
      case $varnumber in
        '@')

          set_variables="
          shift $argnumber
          for ${prefix}n in \$(seq $((argnumber+1)) \$#); do
            setvar \"\$$((argnumber+1))\" \"\${!${prefix}all[\$${prefix}n]}\"
            shift
          done
          "

          intermediary_variables="\"\${${prefix}all[@]}\""
          intermediary_definition="declare -A ${prefix}all
          for ${prefix}n in \$(seq $((argnumber+1)) \$#); do
            ${prefix}all[\$${prefix}n]=${prefix}\$${prefix}n
          done
          "
          ;;
        *)
          set_variables="$(printf_seq $((argnumber+1)) $((varnumber+argnumber)) "setvar \"\$%N\" \"\$$prefix%N\"\n")"
          intermediary_variables="$(printf_seq $((argnumber+1)) $((varnumber+argnumber)) "$prefix%N ")"
          intermediary_definition="local $intermediary_variables"
          ;;
      esac
      ;;
  esac

  eval "
    __$name() $(declare -f $name | tail -n +2)

    $name() {
      if [ -z \${$prefix+x} ]; then
        local $prefix
        $intermediary_definition
      fi
      __$name $arguments $intermediary_variables
      $set_variables
    }
  "
  ClearShadowingCounter=$(($ClearShadowingCounter+1))
}


#!/bin/bash

declare -gA Stream

init_stream() {
  Stream[line]=""
  Stream[index]=0
  Stream[linenumber]=0
  Stream[eof]=false

  next_character
}

get_character() {
  if end_of_file; then
    (>&2 echo 'Tried to get an character after the end of file!')
    exit 1
  elif [ ${Stream[index]} = ${#Stream[line]} ]; then
    setvar "$1" $'\n'
  else
    setvar "$1" "${Stream[line]:${Stream[index]}:1}"
  fi
}

next_character() {
  if [ ${Stream[index]} = ${#Stream[line]} ]; then
    if IFS='' read -r line || [ -n "$line" ]; then
      Stream[line]="$line"
      Stream[index]=0
      Stream[linenumber]=$((${Stream[linenumber]}+1))
    else
      Stream[eof]=true
    fi
  else
    Stream[index]=$((${Stream[index]}+1))
  fi
}

end_of_file() {
  ${Stream[eof]}
}

line_start() {
  [ ${Stream[index]} = 0 ]
}

get_line_number() {
  setvar "$1" ${Stream[linenumber]}
}

get_collumn() {
  setvar "$1" ${Stream[index]}
}

declare -gA Tokens

Tokens[index]=0
Tokens[length]=0

TokenMark=0

store_token() {
  local idvar="$8"
  local index="${Tokens[length]}"

  Tokens[value-$index]="$1"
  Tokens[class-$index]="$2"
  Tokens[glued-$index]="$3"
  Tokens[linenumber_start-$index]="$4"
  Tokens[linenumber_end-$index]="$5"
  Tokens[collumn_start-$index]="$6"
  Tokens[collumn_end-$index]="$7"
  Tokens[index]=$(($index+1))
  Tokens[length]=$(($index+1))

  setvar "$idvar" $index
}
noshadow store_token 7

from_token() {
  setvar "$3" "${Tokens[${2}-${1}]}"
}

all_from_token() {
  local __token="$1"
  shift

  for var in "$@"; do
    from_token "$__token" "$var" "$var"
  done
}

get_selected_token() {
  setvar "$1" $((${Tokens[index]}))
}

clear_tokens() {
  Tokens[length]=$((${Tokens[index]}-$1))
  if [ ${Tokens[index]} -gt ${Tokens[length]} ]; then
    Tokens[index]=${Tokens[length]}
  fi
}

clear_all_tokens() {
  unset Tokens
  declare -gA Tokens
  Tokens[index]=0
  Tokens[length]=0
}

move_back_token_index() {
  Tokens[index]=$((${Tokens[index]}-1))
}

forward_token() {
  Tokens[index]=$((${Tokens[index]}+1))
}

in_topmost_token() {
  [ ${Tokens[index]} = ${Tokens[length]} ]
}


mark_token_position() {
  TokenMark=${Tokens[index]}
}

return_token_to_mark() {
  Tokens[index]=$TokenMark
}


find_token_by() {
  local field="$1"
  local value="$2"
  local token="${Tokens[index]}"
  local tokenvar="$3"
  local tvalue

  while [ $token -ge 0 ]; do
    from_token $token $field tvalue
    if [[ "$tvalue" =~ ^$value$ ]]; then
      setvar "$tokenvar" $token
      return
    else
      token=$(($token-1))
    fi
  done
  setvar "$tokenvar" '-1'
}
noshadow find_token_by 2

declare -gA States

States[index]=0

push_state() {
  States[${States[index]}]=$1
  States[index]=$((${States[index]}+1))
}

pop_state() {
  local index=$((${States[index]}-1))
  States[index]=$index
  setvar "$1" ${States[$index]}
}

in_topmost_state() {
  [ ${States[index]} = 1 ]
}

clear_states() {
  unset States
  declare -gA States
  States[index]=0
  push_state top
}

push_state top


# parse_token varname
# read a token from input and place it's id in the given variable
#
# e.g.
#
#  $ echo "abc" | {
#  > init_stream
#  > get_token token
#  > from_token $token value
#  > from_token $token class
#  > }
#  abc
#  name

parse_token() {
  local token_id_var="$1"   # variables where the token id will be stored

  local linenumber_start    # tokens store starting and ending line and collumn
  local linenumber_end      # numbers for debugging purposes.
  local collumn_start
  local collumn_end

  local state               # describes the parsing context, e.g. if in double quotes or parentheses
  local class=undefined     # token type
  local token=""            # token value
  local c=''                # character being parsed

  local move=true           # if true, the stream will move to the next character after the parsing of the current one.
  local skip_term=true      # if true, the terminating character will not be part of the next token

  local belongs=true        # if false, the current character does not belong to the current token and the latter is finished
  local next_state=none     # if not none, the current state and next state are pushed to the stack, in that order
  local next_class=none     # if not none, after finishing the current token, the next one will be given this class
  local state_end=false     # if true, the current state will be not be pushed in the stack at the end of parsing.

  local glued=true          # true if the token is glued to the previous one

  get_line_number linenumber_start
  get_collumn collumn_start

  # states are stored in a stack, to allow strings like 'a b$(echo c)d e'
  # to be handled by the lexer, where the tokens will be
  # 'a b', $, (, echo, c, ), 'd e'.
  pop_state state

  # the token is done when its class is identified
  while [ $class = undefined ] && ! end_of_file; do
    get_character c

    case $state in
      quoted-escape)
        # if the escaped character is special, expand it before
        # putting it in the token, otherwise just put the character
        case "$c" in
          [bfnrtv]) printf -v token "%s\\$c" "$token" ;;
          *)        token="$token$c" ;;
        esac
        state=double-quotes
        ;;

      unquoted-escape)
        # for escaped spaces and newlines
        case "$c" in
          $'\n') ;;
          *) token="$token$c" ;;
        esac
        pop_state state
        ;;

      single-quotes)
        # accept all characters until an closing single quote is found
        if [ "$c" = "'" ]; then
          class=string
          state_end=true
        else
          token="$token$c"
        fi
        ;;

      double-quotes)
        # characters can be escaped, and expressions substituted in.
        # on substitutions, break the string and restart it after the
        # substitution is finished
        case "$c" in
          '\')
            state=quoted-escape
            ;;
          '$')
            class=string
            next_state=substitution
            ;;
          '"')
            class=string
            state_end=true
            ;;
          *)
            token="$token$c"
            ;;
        esac
        ;;

      whitespace)
        # indentation
        if [ "$c" = ' ' ]; then
          token="$token$c"
        else
          token=${#token}
          move=false
          class=whitespace
          state_end=true
        fi
        ;;

      substitution)
        token='$'
        class=special
        state_end=true
        move=false
        case "$c" in
          '(')
            token='$('
            move=true
            next_state=parentheses
            ;;
          '{')
            token='${'
            move=true
            next_state=curly-braces
            ;;

          [0-9a-zA-Z_]) next_state=variable ;;
          *)            class=string ;;
        esac
        ;;

      variable)
        case "$c" in
          [0-9a-zA-Z_])
            token="$token$c"
            ;;
          *)
            class=name
            state_end=true
            move=false
            ;;
        esac
        ;;

      comment)
        # ignore all until newline
        if [ "$c" = $'\n' ]; then
          token="$c"
          class=newline
          state_end=true
        fi
        ;;

      *)
        # all other contexts follow similar parsing rules,
        # the only difference being what token ends it
        case "$c" in
          "'"|'"'|'('|'['|'{')
            case "$c" in
              "'") next_state=single-quotes ;;
              '"') next_state=double-quotes ;;
              '(') next_state=parentheses;  skip_term=false; next_class=special ;;
              '[') next_state=brackets;     skip_term=false; next_class=special ;;
              '{') next_state=curly-braces; skip_term=false; next_class=special ;;
            esac
            belongs=false
            ;;

          ')'|']'|'}')
            if { { [ "$state" = parentheses  ] && [ ! "$c" = ')' ]; } ||
                 { [ "$state" = brackets     ] && [ ! "$c" = ']' ]; } ||
                 { [ "$state" = curly-braces ] && [ ! "$c" = '}' ]; } ;}; then
              parse_error "unexpected $c on line %line. ${state/-/ }"
            else
              belongs=false
              state_end=true
              skip_term=false
              next_class=special
            fi
            ;;

          ':'|';'|','|'=')
            belongs=false
            skip_term=false
            next_class=special
            ;;

          '\')
            state='unquoted-escape'
            ;;


          '$')
            belongs=false
            next_state=substitution
            skip_term=false
            ;;

          $'\n')
            [ -z "$token" ] && glued=false
            belongs=false
            next_class=newline
            ;;

          ' ')
            if line_start; then
              belongs=false
              skip_term=false
              next_state=whitespace
            elif [ -n "$token" ]; then
              belongs=false
            else
              glued=false
            fi
            ;;

          '#')
            belongs=false
            next_state=comment
            ;;

          *)
            token="$token$c"
            ;;
        esac
        if ! $belongs; then
          # found a terminating character while parsing
          if [ -z "$token" ]; then
            # if the current token is empty, don't return
            # any token, instead restart the loop.

            get_line_number linenumber_start # update starting position
            get_collumn collumn_start        #

            # we skip the terminating character by not
            # adding it to the current empty token
            if $skip_term; then
              token=""
            else
              token="$c"
              skip_term=true
            fi

            # having a next_class means the terminating character
            # forms a token on their own, e.g. '('. It will be
            # a single character token.
            if [ ! $next_class = none ]; then
              class=$next_class
            fi

            if [ ! $next_state = none ]; then
              push_state $state
              state=$next_state
              next_state=none
            fi
          else
            # if the token has any characters, return the token
            # and forget the terminating character.
            class=name
            state_end=false
            next_state=none

            move=false # ensures the terminating character is read again next call
          fi
        fi
        ;;
    esac
    $move && next_character
  done

  $state_end || push_state $state
  [ $next_state = none ] || push_state $next_state

  if end_of_file; then
    if in_topmost_state; then
      if [ -n "$token" ] && [ "$class" = unidentified ]; then
        class=name
      else
        token=eof
        class=eof
      fi
    else
      if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
        POWSCRIPT_INCOMPLETE_STATE="$state"
        token=eof
        class=eof
      else
        unfinished_input_error "$state" "$linenumber_start" "$collumn_start"
      fi
    fi
  fi

  get_collumn collumn_end
  get_line_number linenumber_end

  store_token\
    "$token" "$class" "$glued"\
    "$linenumber_start" "$linenumber_end"\
    "$collumn_start" "$collumn_end"\
    "$token_id_var"
}
noshadow parse_token

get_token() {
  if in_topmost_token; then
    parse_token "$1"
  else
    get_selected_token "$1"
    forward_token
  fi
}

peek_token() {
  if in_topmost_token; then
    parse_token "$1"
    backtrack_token
  else
    get_selected_token "$1"
  fi
}

skip_token() {
  local _
  if in_topmost_token; then
    parse_token _
  else
    forward_token
  fi
}

next_token_is() {
  local token
  peek_token token
  case $# in
    1)
      local class
      from_token $token class class
      [ $class = $1 ]
      ;;
    2)
      local class value
      all_from_token $token class value
      [ "$class" = $1 -a "$value" = $2 ]
      ;;
  esac
}



backtrack_token() {
  local last_token
  move_back_token_index
  peek_token last_token

  case $last_token in
    '('|'$('|'['|'$['|'{'|'${')
      pop_state
      ;;
  esac
}

get_specific_token() {
  local value class required="$1" out="$2"
  get_token_and_set value class
  if [ ! $class = $required ]; then
    parse_error "Wrong token: found a $class of value $value when a $required was required"
  else
    setvar "$out" "$value"
  fi
}
noshadow get_specific_token 1

require_token() {
  local req_class="$1" req_value="$2"
  local value class

  get_token_and_set value class
  if [ ! "$req_class $req_value" = "$class $value" ]; then
    parse_error "Wrong token: found a $class of value $value when a $req_class of value $req_value was required"
  fi
}

get_token_and_set() {
  local __token
  get_token __token
  all_from_token $__token "$@"
}

unfinished_input_error() {
  local token
  local opener=
  local state="$1"
  local line
  local collumn
  case "$state" in
    parentheses)    opener='\$?\('  ;;
    brackets)       opener='\['     ;;
    curly-braces)   opener='\$?\{'  ;;
  esac
  if [ -n "$opener" ]; then
    find_token_by value "$opener" token
    if [ ! $token = -1 ]; then
      from_token $token linenumber_start line
      from_token $token collumn_start collumn
      parse_error "unclosed ${state/-/ }, last open one found in line $line, collumn $collumn"
    else
      parse_error "unclosed ${state/-/ }"
    fi
  else
    if [[ "$state" =~ quotes ]]; then
      line="$2"
      collumn="$3"
      parse_error "unfinished ${state/-/ }, starting in line $line, collumn $collumn"
    else
      parse_error "unexpected eof"
    fi
  fi
}

parse_error() {
  local message="error: ${1//%line/$(get_line_number)}"
  if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
    if ${POWSCRIPT_SHOW_INCOMPLETE_MESSAGE-false}; then
      >&2 echo "$message"
    fi
    POWSCRIPT_INCOMPLETE_STATE="$message"
    exit
  else
    >&2 echo "$message"
    exit 1
  fi
}

tokens_to_json() {
  local token
  init_stream

  echo '{'
  while ! end_of_file; do
    get_token token
    from_token $token value value
    from_token $token class class
    from_token $token glued glued
    echo "  ${token}: {"
    echo "    'value': '$value'"
    echo "    'class': '$class'"
    echo "    'glued': $glued"
    echo '  }'
  done
  echo '}'
}
declare -gA Asts

Asts[index]=0
Asts[length]=0
Asts[required-indent]=0

declare -gA IndentStack

IndentStack[index]=0
IndentStack[starting-block]=false
IndentStack[0]=0


ast_new_indentation() {
  local indent

  ast_indentation_required indent

  ast_push_indentation $((indent+1))
  IndentStack[starting-block]=true
}


ast_test_indentation() {
  local value="$1" class="$2" out="$3"
  local req found result temp_result
  ast_indentation_required req
  ast_count_indentation "$value" $class found

  if ${IndentStack[starting-block]}; then
    if [ $found -ge $req ]; then
      IndentStack[starting-block]=false
      IndentStack[${IndentStack[index]}]=$found
      result=ok
    else
      result=error-start
    fi
  else
    if [ $found -eq $req ]; then
      result=ok

    elif [ $found -eq -1 ]; then
      result=error-eof

    elif [ $found -lt $req ]; then
      ast_pop_indentation
      ast_indentation_required req
      if [ $found -eq $req ]; then
        result=end
      else
        result=error-exact
      fi
    else
      result=error-exact
    fi
  fi
  setvar "$out" $result
}
noshadow ast_test_indentation 2


ast_update_indentation() {
  IndentStack[${IndentStack[index]}]=$1
}

ast_pop_indentation() {
  IndentStack[index]=$((${IndentStack[index]}-1))
}

ast_push_indentation() {
  IndentStack[index]=$((${IndentStack[index]}+1))
  ast_update_indentation $1
}

ast_indentation_required() {
  setvar "$1" ${IndentStack[${IndentStack[index]}]}
}

ast_count_indentation() {
  case "$2" in
    whitespace) setvar "$3" "$1" ;;
    eof)        setvar "$3" -1   ;;
    *)          setvar "$3" 0    ;;
  esac
}

ast_indentation_layers() {
  setvar "$1" ${IndentStack[index]}
}

declare -gA AstStates

AstStates[index]=0
AstStates[0]=top

ast_push_state() {
  local index=$((${AstStates[index]}+1))

  AstStates[index]=$index
  AstStates[$index]=$1
}

ast_pop_state() {
  AstStates[index]=$((${AstStates[index]}-1))
}

ast_last_state() {
  setvar "$1" "${AstStates[${AstStates[index]}]}"
}

ast_clear_states() {
  unset AstStates
  declare -gA AstStates
  AstStates[index]=0
  AstStates[0]=top
}

new_ast() {
  local index="${Asts[index]}"
  local length="${Asts[length]}"

  setvar "$1" "$index"

  Asts[type-$index]=
  Asts[value-$index]=
  Asts[children-$index]=""

  if [ ! $index = $length ]; then
    Asts[index]=$(($index+1))
  else
    Asts[index]=$(($length+1))
  fi
  Asts[length]=$(($length+1))
}
noshadow new_ast

make_ast() {
  local __newast __newchild
  new_ast __newast
  ast_set "$__newast" head  "$2"
  ast_set "$__newast" value "$3"
  for __newchild in ${@:4}; do
    ast_push_child "$__newast" $__newchild
  done
  setvar "$1" "$__newast"
}

from_ast() {
  setvar "$3" "${Asts["$2-$1"]}"
}

ast_set() {
  Asts["$2-$1"]="$3"
}

ast_set_to_overwrite() {
  Asts[index]="$1"
}

ast_push_child() {
  Asts["children-$1"]="${Asts["children-$1"]} $2"
}

ast_unshift_child() {
  Asts["children-$1"]="$2 ${Asts["children-$1"]}"
}

ast_clear_all() {
  unset Asts
  declare -gA Asts

  Asts[index]=0
  Asts[length]=0
  Asts[required-indent]=0
}

ast_print() {
  printf '`'
  ast_print_child "$1" "$2"
  echo '`'
}

ast_print_child() {
  local ast=$1 indent=
  local ast_head ast_value ast_children
  from_ast $ast head     ast_head
  from_ast $ast value    ast_value
  from_ast $ast children ast_children

  local child_array=( $ast_children )

  case $ast_head in
    name)
      printf "%s" "$ast_value"
      ;;
    cat)
      local child
      for child in ${child_array[@]:0:$((${#child_array[@]}-1))}; do
        ast_print_child $child
      done
      ast_print_child ${child_array[${#child_array[@]}-1]}
      ;;
    string)
      printf "'%s'" "$ast_value"
      ;;
    call)
      local command=${child_array[0]}
      local argument

      ast_print_child $command
      for argument in ${child_array[@]:1}; do
        printf ' '
        ast_print_child $argument
      done
      ;;
    assign)
      local name=${child_array[0]} value=${child_array[1]}
      ast_print_child $name
      printf '='
      ast_print_child $value
      ;;
    simple-substitution)
      printf '$%s' "$ast_value"
      ;;
    indexing-substitution)
      printf '${%s[' "$ast_value"
      ast_print_child ${child_array[0]}
      printf ']}'
      ;;
    command-substitution)
      printf '$('
      ast_print_child ${child_array[0]}
      printf ')'
      ;;
    function-def)
      local name=${child_array[0]} args=${child_array[1]} block=${child_array[2]}

      ast_print_child $name
      ast_print_child $args
      echo
      ast_print_child $block
      ;;
    list)
      local element

      printf '( '
      for element in "${child_array[@]}"; do
        ast_print_child $element
        printf ' '
      done
      printf ')'
      ;;

    block)
      local statement

      for statement in "${child_array[@]}"; do
        printf "%$((ast_value*2)).s" ''
        ast_print_child $statement
        echo
      done
      ;;
  esac
}



# try_parse_ast
#
# try parsing an ast expression from the input,
# printing 'top' on success or the last
# parser state on failure.

try_parse_ast() {
  (
    local ast
    POWSCRIPT_INCOMPLETE_STATE=

    trap '
      if [ -n "$POWSCRIPT_INCOMPLETE_STATE" ]; then
        echo "$POWSCRIPT_INCOMPLETE_STATE"
      else
        ast_last_state
      fi
      exit' EXIT

    POWSCRIPT_ALLOW_INCOMPLETE=true parse_ast ast
    exit
  )
}

# parse_ast $out
#
# parse an ast expression form the input,
# storing it in $out.

parse_ast() {
  parse_ast_linestart "$1"
}

ast_error() {
  local message="$1"

  if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
    POWSCRIPT_INCOMPLETE_STATE="error: $message"
    if ${POWSCRIPT_SHOW_INCOMPLETE_MESSAGE-false}; then
      >&2 echo "$message"
    fi
  else
    >&2 echo "$message"
  fi
  exit
}

# parse_ast_linestart $out
#
# test that there is no indentation before proceeding
# to parse the expression.

parse_ast_linestart() {
  local value class linenumber_start

  get_token_and_set value class linenumber_start

  if [ "$class" = whitespace ]; then
    ast_error "indentation error at line $linenumber_start, unexpected indentation of $value."
  else
    backtrack_token
    parse_ast_top "$1"
  fi
}
noshadow parse_ast_linestart


# parse_ast_top $out
#
# analyze first expression and dispatch to the
# appropriate function based on it.

parse_ast_top() {
  local out="$1"
  local expr expr_head

  parse_ast_expr expr
  from_ast $expr head expr_head

  case $expr_head in
    name)
      local expr_value
      from_ast $expr value expr_value
      case "$expr_value" in
        'if')      parse_ast_if 'if' "$out" ;;
        'while')   parse_ast_while   "$out" ;;
        'switch')  parse_ast_switch  "$out" ;;
        'require') parse_ast_require "$out" ;;
        *)
          parse_ast_post_top_name $expr "$out";;
      esac
      ;;
    newline)
      setvar "$out" -1
      ;;
    *)
      parse_ast_commandcall $expr "$out"
      ;;
  esac
}
noshadow parse_ast_top


# parse_ast_expr $out
#
# basic expression, which can be a name,
# string, substitution or concatenation.

parse_ast_expr() {
  local out="$1"
  local value class glued=true
  local state=first
  local expression child catnum=0

  new_ast expression

  #>&2 echo "-----"
  while [ ! $state = finished ]; do
    get_token_and_set value class glued
    while [ $class = whitespace ]; do
      get_token_and_set value class glued
    done

    #>&2 echo "token: $class $value"

    if $glued || [ $state = first ]; then
      case $state in
        first)
          child=$expression
          state=second
          ;;
        second)
          new_ast expression
          ast_set $expression head cat
          ast_push_child $expression $child
          new_ast child
          state=cat
          catnum=1
          ;;
        cat)
          new_ast child
          catnum=$((catnum+1))
          ;;
      esac

      case $class in
        name|string)
          ast_set $child head  $class
          ast_set $child value "$value"
          ;;
        special)
          case "$value" in
            '$')
              ast_set_to_overwrite $child
              parse_ast_substitution child
              ;;
            '${')
              ast_set_to_overwrite $child
              parse_ast_curly_substitution child
              ;;
            '$(')
              ast_set_to_overwrite $child
              parse_ast_command_substitution child
              ;;
            '(')
              if [ $state = cat ]; then
                backtrack_token
                state=finished
              else
                ast_set_to_overwrite $child
                parse_ast_list child
              fi
              ;;
            ')')
              #>&2 echo "xyz"
              local ast_state
              ast_last_state ast_state
              if [ $state = cat ]; then
                backtrack_token
                state=finished
              elif [ "$ast_state" = '$(' ]; then
                ast_set $child head command-substitution-end
              else
                ast_error "unmatched ) found."
              fi
              ;;
            *)
              backtrack_token
              state=finished
              ;;
          esac
          ;;
        newline|eof)
          case $state in
            first|second)
              ast_set $expression head $class
              state=finished
              ;;
            *)
              backtrack_token
              state=finished
              ;;
          esac
          ;;
      esac
      [ $state = cat ] && ast_push_child $expression $child
    else
      backtrack_token
      state=finished
    fi
  done
  #>&2 echo "expr: $(from_ast $expression head) $(ast_print $expression) / $catnum"
  if [ $catnum = 1 ]; then
    from_ast $expression children child
    setvar "$out" $child
  else
    setvar "$out" $expression
  fi
}
noshadow parse_ast_expr

parse_ast_specific_expr() {
  local expr expr_head required="$1" out="$2"
  parse_ast_expr expr
  from_ast $expr head expr_head
  if [ $expr_head = $required ]; then
    setvar "$out" $expr
  else
   ast_error "Wrong expression: Found a $expr_head when a $required was required"
 fi
}
noshadow parse_ast_specific_expr 1

parse_ast_substitution() {
  local subst out="$1"
  local value class

  get_token_and_set value class

  case "$class" in
     special)
       ast_error "unimplemented"
       ;;
    name)
      if next_token_is special "["; then
        local index
        make_ast subst indexing-substitution "$value"
        skip_token
        parse_ast_specific_expr name index
        ast_push_child $subst $index
        require_token special "]"
      else
        make_ast subst simple-substitution "$value"
      fi
      ;;
  esac
  setvar "$out" $subst
}
noshadow parse_ast_substitution

parse_ast_curly_substitution() {
  local out="$1"
  local subst varname delimiter

  get_specific_token name varname
  get_specific_token special delimiter

  case "$delimiter" in
    '}')
      make_ast subst simple-substitution "$varname"
      ;;
    '[')
      local index
      make_ast subst indexing-substitution "$varname"
      parse_ast_specific_expr name index
      ast_push_child $subst $index

      require_token special ']'
      require_token special '}'
      ;;
    *)
      ast_error "unimplemented"
      ;;
  esac

  setvar "$out" $subst
}
noshadow parse_ast_curly_substitution

parse_ast_command_substitution() {
  local out="$1"
  local cmd call

  make_ast "$out" command-substitution ''

  ast_push_state '$('
  parse_ast_expr cmd
  parse_ast_commandcall $cmd call
  ast_pop_state

  ast_push_child "${!out}" $call
}
noshadow parse_ast_command_substitution


# parse_ast_post_top_name $name $ast
#
# parse top ast that starts with a non-special name
# or a string

parse_ast_post_top_name() {
  local name_ast="$1" out="$2"
  local value class glued

  get_token_and_set value class glued

  case "$class: $value" in
    'special: =')
      local assign

      new_ast assign
      ast_set $assign head assign
      ast_push_child $assign $name_ast

      parse_ast_arguments $assign

      setvar "$out" $assign
      ;;
    'special: (')
      backtrack_token
      parse_ast_function_definition $name_ast "$out"
      ;;
    *)
      backtrack_token
      parse_ast_commandcall $name_ast "$out"
      ;;
  esac
}
noshadow parse_ast_post_top_name 1


# parse_ast_commandcall $command $out
#
# parse a command call, consisting of
# a command and a series of space
# separated arguments

parse_ast_commandcall() {
  local command_ast=$1 out="$2"
  local expression child expr_head=none

  make_ast expression call '' $command_ast

  parse_ast_arguments $expression

  setvar "$out" $expression
}
noshadow parse_ast_commandcall 1

parse_ast_arguments() {
  local expr="$1"
  local expr_head=none child unfinished=true state state_s

  ast_last_state state
  case $state in
    '$(')
      state_s='c'
      ;;
    top)
      state_s='t'
      ;;
    *)
      state_s='o'
      ;;
  esac


  while $unfinished; do
    parse_ast_expr child
    from_ast $child head expr_head

    case "$state_s/$expr_head" in
      'c/command-substitution-end'|'t/newline'|'t/eof'|'o/newline')
        unfinished=false
        ;;
      *eof)
        if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
          POWSCRIPT_INCOMPLETE_STATE=$state
          exit
        else
          ast_error "unexpected end of file while parsing command."
        fi
        ;;
      *newline)
        ;;
      *)
        ast_push_child $expr $child
        ;;
    esac
  done
}


# parse_ast_if $block_type $out
#
# parses a if statement, which is
# a conditional expression, followed
# by a newline, block, and possibly an
# else or elif statements

parse_ast_if() {
  local block_type=$1 out="$2"
  local expr conditional block

  new_ast expr
  ast_set $expr head 'if'

  parse_ast_conditional conditional
  parse_ast_require_newline "condition in if statement"
  parse_ast_block $block_type block

  ast_push_child $expr $conditional
  ast_push_child $expr $block

  parse_ast_post_if $expr

  setvar "$out" $expr
}
noshadow parse_ast_if 1

parse_ast_post_if() {
  local if_ast="$1"
  local value class clause_type

  get_token_and_set value class

  if [ $class = name ]; then
    clause_type="$value"
  else
    clause_type=none
  fi

  case "$clause_type" in
    else)
      local else_ast else_block
      new_ast else_ast
      ast_set $else_ast head else

      parse_ast_require_newline "else statement"
      parse_ast_block el else_block

      ast_push_child $else_ast $else_block
      ast_push_child $if_ast $else_ast
      ;;
    elif)
      local elif_ast
      parse_ast_if elif_ast ef

      ast_push_child $if_ast $elif_ast
      ;;
    *)
      local end_ast
      new_ast end_ast
      ast_set $end_ast head end_if

      ast_push_child $if_ast $end_ast
      ;;
  esac
}

parse_ast_conditional() {
  local out="$1"
  local condition
  local initial initial_head initial_value

  new_ast condition
  ast_set $condition head condition

  parse_ast_expr initial

  from_ast $initial head  initial_head
  from_ast $initial value initial_value

  if [ "$initial_head: $initial_head" = "name: not" ]; then
    local not_expr
    parse_ast_conditional not_expr

    ast_set $condition value "not"
    ast_push_child $condition $not_expr
  else

    local value class is_command=false
    get_token_and_set value class

    if [ ! $class = name ]; then
      backtrack_token
      is_command=true
    else
      case "$value" in
        is|isnt|'>'|'<'|'<='|'>='|'!='|and|or|match)
          ast_set $condition value "$value"
          ;;
        *)
          backtrack_token
          is_command=true
          ;;
      esac
    fi

    if $is_command; then
      local command

      ast_set $condition value "$command"
      parse_ast_commandcall $initial command

      ast_push_child $condition $command
      backtrack_token
    else
      local left right
      left=$initial
      parse_ast_expr right

      ast_push_child $condition $left
      ast_push_child $condition $right
    fi
  fi
  setvar "$out" $condition
}
noshadow parse_ast_conditional



parse_ast_function_definition() {
  local name=$1 out="$2"
  local expr args block

  make_ast expr function-def

  parse_ast_specific_expr list args
  parse_ast_require_newline "function definition"
  parse_ast_block fn block

  ast_push_child $expr $name
  ast_push_child $expr $args
  ast_push_child $expr $block

  setvar "$out" $expr
}
noshadow parse_ast_function_definition 1

parse_ast_require_newline() {
  local nl nl_head
  parse_ast_expr nl
  from_ast $nl head nl_head
  case $nl_head in
    newline)
      ;;
    eof)
      if ! ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
        ast_error "unexpected end of file after $1"
      fi
      ;;
    *)
      ast_error "trailing expression after ${1}: $(ast_print $nl) :: $(from_ast $nl head)"
      ;;
  esac
}

parse_ast_block() {
  local state=$1 out="$2"
  local expr child indent_state indent_layers
  local value class linenumber_start ln="0"

  new_ast expr
  ast_set $expr head block

  ast_push_state $state
  ast_new_indentation

  ast_indentation_layers indent_layers
  ast_set $expr value $indent_layers

  indent_state=ok

  while [ ! $indent_state = end ]; do
    get_token_and_set value class linenumber_start

    ast_test_indentation "$value" $class indent_state

    case $indent_state in
      ok)
        parse_ast_top child
        if [ ! "$child" = -1 ]; then
          ast_push_child $expr $child
          ln="$linenumber_start"
        fi
        ;;
      error*)
        if [ $class = eof ] && ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
          if [ ! "$indent_state" = error-eof ] || [ "$ln" = "$linenumber_start" ]; then
            POWSCRIPT_INCOMPLETE_STATE="$(ast_last_state)"
          else
            POWSCRIPT_INCOMPLETE_STATE="top"
          fi
          exit
        fi

        local req found or_more=""
        [ $indent_state = error-start ] && or_more=" or more"

        ast_indentation_required req
        ast_count_indentation "$value" $class found
        ast_error "indentation error at line $linenumber_start, expected $req spaces$or_more, found $found."
        ;;
    esac
  done

  ast_pop_state
  setvar "$out" $expr
  backtrack_token
}
noshadow parse_ast_block 1



parse_ast_list() {
  local out="$1"
  local expr child open=true
  local t class value

  new_ast expr
  ast_set $expr head list

  while $open; do
    get_token_and_set value class

    if [ "$class: $value" = "special: )" ]; then
      open=false
    else
      backtrack_token
      parse_ast_expr child

      ast_push_child $expr $child
    fi
  done

  setvar "$out" $expr
}
noshadow parse_ast_list

declare -gA PowscriptBackends

bash_interactive() {
  local wfifo="$1"
  local rfifo="$2"
  local end="$3"
  local code="__PowscriptCompiledCode__"
  local line="__PowscriptCodeLine__"
  local result="__PowscriptResultLine__"
  bash -c "
    trap 'echo \"#<<END.$end>>\" >>\"$rfifo\"' EXIT
    $code=
    $line=
    $result=
    while true; do
      IFS= read -r $line <'$wfifo'
      if [ \"\$$line\" = '#<<END>>' ] ; then
        2>&1 eval \"\$$code\" >>'$rfifo'
        echo '#<<END.$end>>' >>'$rfifo'
        $code=
      else
        $code=\"\$$code\"\$'\n'\"\$$line\"
      fi
    done
  " 2>/dev/null
}


bash_compile() {
  local expr=$1 out="$2"
  local expr_head expr_value expr_children

  from_ast $expr head expr_head

  case "$expr_head" in
    name)
      from_ast $expr value "$out"
      ;;

    string)
      from_ast $expr value expr_value
      setvar "$out" "'$expr_value'"
      ;;

    cat)
      local child compiled result=""
      from_ast $expr children expr_children
      for child in $expr_children; do
        bash_compile $child compiled
        result="$result$compiled"
      done
      setvar "$out" "$result"
      ;;

    if|elif)
      local expr_children
      local condition block post_if

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} condition
      bash_compile ${expr_children[1]} block
      bash_compile ${expr_children[2]} post_if

      setvar "$out" "$expr_head $condition; then"$'\n'"${block:2:$((${#block}-4))}"$'\n'"$post_if"
      ;;
    else)
      local expr_children
      local block

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} block

      setvar "$out" "else"$'\n'"${block:2:$((${#block}-4))}"$'\n'"fi"
      ;;

    end_if)
      setvar "$out" "fi"
      ;;

    simple-substitution)
      local name
      from_ast $expr value name
      setvar "$out" "\"\${$name}\""
      ;;

    indexing-substitution)
      local name index expr_children

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      from_ast $expr value name
      bash_compile ${expr_children[0]} index

      setvar "$out" "\"\${$name[$index]}\""
      ;;
    command-substitution)
      local call_ast call

      from_ast $expr children call_ast

      bash_compile $call_ast call

      setvar "$out" '$('"$call"')'
      ;;

    call)
      local command argument compiled result
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} result

      for argument in ${expr_children[@]:1}; do
        bash_compile $argument compiled
        result="$result $compiled"
      done
      setvar "$out" "$result"
      ;;

    assign)
      local name value
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} name
      bash_compile ${expr_children[1]} value

      setvar "$out" "$name=$value"
      ;;

    list)
      local expr_children child_ast child result

      from_ast $expr children expr_children

      result="( "
      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result$child "
      done

      setvar "$out" "$result)"
      ;;

    function-def)
      local name args_ast arg_assign_ast argval_ast block_ast block
      local args arg argval argnum locals_ast argname_ast

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} name

      args_ast=${expr_children[1]}
      block_ast=${expr_children[2]}


      new_ast locals_ast
      ast_set $locals_ast head local

      from_ast $args_ast children args


      argnum=1
      for arg in $args; do
        make_ast argval_ast simple-substitution $argnum
        make_ast arg_assign_ast assign '' $arg $argval_ast
        ast_push_child $locals_ast $arg_assign_ast
        argnum=$((argnum+1))
      done
      ast_unshift_child $block_ast $locals_ast

      bash_compile $block_ast block

      setvar "$out" "$name() $block"
      ;;

    local)
      local result="local" child_ast child
      from_ast $expr children expr_children

      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result $child"
      done

      setvar "$out" "$result"
      ;;
    block)
      local child_ast child result
      from_ast $expr children expr_children

      result='{'
      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result"$'\n'"$child"
      done
      result="$result"$'\n}'

      setvar "$out" "$result"
      ;;

    condition)
      local op left right quoted=no
      from_ast $expr value op
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      case "$op" in
        command)
          bash_compile ${expr_children[0]} "$out"
          ;;
        not)
          bash_compile ${expr_children[0]} right
          setvar "$out" "! $right"
          ;;
        *)
          bash_compile ${expr_children[0]} left
          bash_compile ${expr_children[1]} right

          case "$op" in
            'is'|'=')  op='='    quoted=single ;;
            '>')       op='-gt'  quoted=single ;;
            '>=')      op='-ge'  quoted=single ;;
            '<')       op='-lt'  quoted=single ;;
            '<=')      op='-le'  quoted=single ;;
            'match')   op='=~'   quoted=double ;;
            'and')     op='&&' ;;
            'or')      op='||' ;;
          esac

          case $quoted in
            double) setvar "$out" "[[ $left $op $right ]]" ;;
            single) setvar "$out"  "[ $left $op $right ]"  ;;
            no)     setvar "$out"    "$left $op $right"    ;;
          esac
          ;;
      esac
      ;;
  esac
}
noshadow bash_compile 1

select_backend() {
  eval "
    compile_to_backend () { ${1}_compile \"\$@\"; }
    interactive_compile_target () { ${1}_interactive \"\$@\"; }
  "
}


PowscriptTempDirectory="$(mktemp -d --suffix=".powscript")"

powscript_temp_name() {
  local suffix=".powscript$1"
  setvar "$2" "$(mktemp -u --suffix="$suffix" -p "$PowscriptTempDirectory")"
}

powscript_make_temp() {
  powscript_temp_name "$1" "$2"
  touch "${!2}"
}

powscript_make_fifo() {
  powscript_temp_name "$1" "$2"
  mkfifo "${!2}"
}

powscript_clean_up() {
  [ -d "$PowscriptTempDirectory" ] && rm -r "$PowscriptTempDirectory"
  exit 0
}

trap 'powscript_clean_up' ERR EXIT

PowscriptBackend=bash
PowscriptInteractiveMode=nofile
PowscriptCompileFile=false

declare -gA PowscriptFiles
PowscriptFileNumber=0

powscript_parse_options() {
  while [ "$#" -gt 0 ]; do
    case "$1" in
      '-i'|'-interactive')
        PowscriptInteractiveMode=yes
        shift
        ;;
      '--to')
        shift
        case "$1" in
          bash|sh)
            PowscriptBackend="$1"
            ;;
          *)
            >&2 echo "Invalid powscript backend $1"
            exit 1
            ;;
        esac
        ;;
      '-c'|'--compile')
        PowscriptCompileFile=true
        shift
        ;;

      '-'*)
        >&2 echo "Invalid powscript option $1"
        exit 1
        ;;

      *)
        PowscriptFiles[$PowscriptFileNumber]="$1"
        PowscriptFileNumber=$((PowscriptFileNumber+1))
        shift
        ;;
    esac
  done

  if $PowscriptCompileFile && [ "$PowscriptFileNumber" -eq 0 ]; then
    >&2 echo "No input files given"
  fi

  if [ $PowscriptInteractiveMode = nofile ] && [ "$PowscriptFileNumber" -gt 0 ]; then
    PowscriptInteractiveMode=false
  else
    PowscriptInteractiveMode=true
  fi
}

powscript_is_interactive() {
  $PowscriptInteractiveMode
}
powscript_compile_files() {
  local output=${1-/dev/stdout}
  local ast

  init_stream
  while ! end_of_file; do
    parse_ast ast
    compile_to_backend $ast >$output
  done
}

InteractiveFileLineNumber=0

interactive_mode() {
  local ast code compiled_code line="" state=none
  local proc rfifo wfifo end_token result
  local powhistory="${POWSCRIPT_HISTORY_FILE-$HOME/.powscript_history}"
  local extra_line=''
  local compile_flag=false ast_flag=false echo_flag=false incomplete_flag=false

  [ ! -f "$powhistory" ] && echo >"$powhistory"
  history -c
  history -r "$powhistory"

  powscript_make_fifo ".interactive.wfifo" wfifo
  powscript_make_fifo ".interactive.rfifo" rfifo
  powscript_temp_name ".end" end_token

  interactive_compile_target "$wfifo" "$rfifo" "$end_token" &
  proc="$!"

  exec 3<>"$wfifo"
  exec 4<>"$rfifo"

  while ps -p $proc >/dev/null; do
    result=

    if [ -n "$extra_line" ]; then
      line="$extra_line"
      extra_line=""
    else
      read_powscript top line
    fi
    code="$line"

    case "$code" in
      '.compile')
        toggle_flag compile_flag
        ;;
      '.ast')
        toggle_flag ast_flag
        ;;
      '.echo')
        toggle_flag echo_flag
        ;;
      '.incomplete')
        toggle_flag incomplete_flag
        ;;
      '.show '*)
        show_ast "${code//.show /}"
        echo
        ;;
      *)
        state=none
        while [ ! "$state" = top ]; do
          clear_compilation
          state="$( { init_stream; POWSCRIPT_SHOW_INCOMPLETE_MESSAGE=$incomplete_flag try_parse_ast; } <<< "$code" )"
          case "$state" in
            top)
              clear_compilation
              { init_stream; parse_ast ast; } <<< "$code"$'\n'
              ;;
            error*)
              >&2 echo "$state"
              state=none
              code=
              ;;
            *)
              read_powscript "$state" line
              code="$code"$'\n'"$line"
              ;;
          esac
        done
        if [ ! "$line" = '' ] && [ ! "$line" = "$code" ]; then
          code="$(echo "$code" | head -n -1)"$'\n'
          extra_line="$line"
        fi

        history -s "$code"

        if $echo_flag; then
          echo "---- CODE ECHO -----"
          echo "$code"
          echo "---------------------"
         fi

        if $ast_flag; then
          echo "---- SYNTAX TREE ----"
          show_ast $ast
          echo "---------------------"
        fi
        compile_to_backend $ast compiled_code
        if $compile_flag; then
          echo "--- COMPILED CODE ---"
          echo "$compiled_code"
          echo "---------------------"
        fi
        echo "$compiled_code" >>"$wfifo"
        echo "#<<END>>" >>"$wfifo"
        while [ ! "$result" = "#<<END.$end_token>>" ]; do
          IFS= read -r result <"$rfifo"
          [ ! "$result" = "#<<END.$end_token>>" ] && echo "$result"
        done
        echo
        ;;
    esac
  done
  history -w "$powhistory"

  rm $wfifo
  rm $rfifo
}

clear_compilation() {
  clear_all_tokens
  clear_states
  ast_clear_all
  ast_clear_states
}

show_ast() {
  echo "id:       $1"
  echo "head:     $(from_ast $1 head)"
  echo "value:    $(from_ast $1 value)"
  echo "children: $(from_ast $1 children)"
  ast_print $1
}

toggle_flag() {
  if ${!1}; then
    setvar "$1" false
  else
    setvar "$1" true
  fi
}

read_powscript() {
  IFS="" read -r -e -p "$(format_powscript_prompt "$1")" "$2"
  InteractiveFileLineNumber=$((InteractiveFileLineNumber+1))
}

format_powscript_prompt() {
  local state_name=$1 state

  case $state_name in
    top) state="--" ;;
    double-quotes) state='""' ;;
    single-quotes) state="''" ;;
    *) state="$state_name" ;;

  esac

  local default_prompt='pow[%L]%S> '
  local prompt="${POWSCRIPT_PS1-$default_prompt}"

  prompt="${prompt//%L/$(printf '%.3d' $InteractiveFileLineNumber)}"
  prompt="${prompt//%S/$(printf '%3s'  $state)}"

  echo "$prompt"
}



powscript_parse_options "$@"
select_backend $PowscriptBackend

if powscript_is_interactive; then
  interactive_mode
else
  echo "TODO: COMPILATION"
fi

${POWSCRIPT_DEBUG-false} || powscript_clean_up
