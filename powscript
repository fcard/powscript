#!/bin/bash

set -E

PowscriptSourceDirectory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# powscript_source
#
# include source relatively from the powscript source code directory

powscript_source() {
  source "$PowscriptSourceDirectory/$1"
}


# printf_seq $start $end $format
#
# calls printf on each element of $(seq $start $end)
# the specifier %N is used to reference the current number.

printf_seq() {
  local start="$1" end="$2" format="$3"
  for n in $(seq $start $end); do
    printf "${format//%N/$n}"
  done
}


# setvar $varname $value
#
# dynamic variable assignation

setvar() {
  if [ -n "$1" ]; then
    printf -v "$1" '%s' "$2"
  else
    echo "$2"
  fi
}

# noshadow name ${argnumber:-0} ${varnumber:-1}
#
# wrap the function so that the name of the out variables
# (assumed to be the last arguments) do not conflict
# with the local variables declared within the function.
#
# Passing @ instead of a number means the number of arguments
# is variable. You may have a argnumber or varnumber be @, but
# not both.

ClearShadowingCounter=0

noshadow() {
  local name="$1"
  local argnumber="${2:-0}"
  local varnumber="${3:-1}"
  local arguments set_variables intermediary_variables intermediary_definition
  local prefix="__noshadow_${ClearShadowingCounter}_"

  case $argnumber in
    '@')
      arguments="\"\${@:1:\$((\$# - $varnumber))}\""

      set_variables="shift \$((\$# - $varnumber))
        $(printf_seq 1 $varnumber\
          "setvar \"\$%N\" \"\$$prefix%N\"\n")"

      intermediary_variables="$(printf_seq 1 $varnumber "$prefix%N")"
      intermediary_definition="local $intermediary_variables"
      ;;
    *)
      arguments="$(printf_seq 1 $argnumber '"$%N" ')"

      case $varnumber in
        '@')
          local argshift="shift $((argnumber-1))"
          [ $argnumber = 0 ] && argshift=

          set_variables="#
          $argshift
          for ${prefix}n in \$(seq $((argnumber+1)) \$#); do
            setvar \"\$$((argnumber+1))\" \"\${!${prefix}all[\$${prefix}n]}\"
            shift
          done"

          intermediary_variables="\"\${${prefix}all[@]}\""
          intermediary_definition="declare -A ${prefix}all
          for ${prefix}n in \$(seq $((argnumber+1)) \$#); do
            ${prefix}all[\$${prefix}n]=${prefix}\$${prefix}n
          done"
          ;;
        *)
          set_variables="$(printf_seq $((argnumber+1)) $((varnumber+argnumber)) "setvar \"\$%N\" \"\$$prefix%N\"\n")"
          intermediary_variables="$(printf_seq $((argnumber+1)) $((varnumber+argnumber)) "$prefix%N ")"
          intermediary_definition="local $intermediary_variables"
          ;;
      esac
      ;;
  esac

  ${ShadowingOp-eval} "
__shadowing_$name() $(${ShadowingGetFunc-declare} -f $name | tail -n +2)

$name() {
  if [ -z \${$prefix+x} ]; then
    local $prefix
    $intermediary_definition
  fi
  __shadowing_$name $arguments $intermediary_variables
  $set_variables
}
"
  ClearShadowingCounter=$(($ClearShadowingCounter+1))
}

# FILE: "$PowscriptSourceDirectory/helper.bash"

#!/bin/bash

declare -gA Stream

init_stream() {
  Stream[line]=""
  Stream[index]=0
  Stream[linenumber]=0
  Stream[eof]=false

  next_character
}

get_character() {
  if end_of_file; then
    (>&2 echo 'Tried to get an character after the end of file!')
    exit 1
  elif [ ${Stream[index]} = ${#Stream[line]} ]; then
    setvar "$1" $'\n'
  else
    setvar "$1" "${Stream[line]:${Stream[index]}:1}"
  fi
}

next_character() {
  local line
  if [ ${Stream[index]} = ${#Stream[line]} ]; then
    if IFS='' read -r line || [ -n "$line" ]; then
      Stream[line]="$line"
      Stream[index]=0
      Stream[linenumber]=$((${Stream[linenumber]}+1))
    else
      Stream[eof]=true
    fi
  else
    Stream[index]=$((${Stream[index]}+1))
  fi
}


__shadowing_get_rest_of_line() {
  local line collumn out="$1"
  line="${Stream[line]}"
  get_collumn collumn
  setvar "$out" "${line:$collumn}"
}

get_rest_of_line() {
  if [ -z ${__noshadow_0_+x} ]; then
    local __noshadow_0_
    local __noshadow_0_1
  fi
  __shadowing_get_rest_of_line  __noshadow_0_1
  setvar "$1" "$__noshadow_0_1"
}



end_of_file() {
  ${Stream[eof]}
}

line_start() {
  [ ${Stream[index]} = 0 ]
}

jump_to_collumn() {
  Stream[index]=$1
}

get_line_number() {
  setvar "$1" ${Stream[linenumber]}
}

get_collumn() {
  setvar "$1" ${Stream[index]}
}

# FILE: lexer/stream.bash
declare -gA Tokens

Tokens[index]=0
Tokens[length]=0

TokenMark=0


__shadowing_store_token() {
  local idvar="$8"
  local index="${Tokens[length]}"

  Tokens[value-$index]="$1"
  Tokens[class-$index]="$2"
  Tokens[glued-$index]="$3"
  Tokens[linenumber_start-$index]="$4"
  Tokens[linenumber_end-$index]="$5"
  Tokens[collumn_start-$index]="$6"
  Tokens[collumn_end-$index]="$7"
  Tokens[index]=$(($index+1))
  Tokens[length]=$(($index+1))

  setvar "$idvar" $index
}

store_token() {
  if [ -z ${__noshadow_1_+x} ]; then
    local __noshadow_1_
    local __noshadow_1_8
  fi
  __shadowing_store_token "$1" "$2" "$3" "$4" "$5" "$6" "$7"  __noshadow_1_8
  setvar "$8" "$__noshadow_1_8"
}


from_token() {
  setvar "$3" "${Tokens[${2}-${1}]}"
}

all_from_token() {
  local __token="${@:$#}"

  while [ $# -gt 1 ]; do
    case "$1" in
      '-v'|'--value')
        from_token $__token value "$2"
        shift 2
        ;;
      '-c'|'--class')
        from_token $__token class "$2"
        shift 2
        ;;
      '-ls'|'--line-start')
        from_token $__token linenumber_start "$2"
        shift 2
        ;;
      '-le'|'--line-end')
        from_token $__token linenumber_end "$2"
        shift 2
        ;;
      '-g'|'--glued')
        from_token $__token glued "$2"
        shift 2
        ;;
      '-cs'|'--collumn-start')
        from_token $__token collumn_start "$2"
        shift 2
        ;;
      '-ce'|'--collumn-end')
        from_token $__token collumn_end "$2"
        shift 2
        ;;
      '-i'|'--id')
        setvar "$2" $__token
        shift 2
        ;;
      *)
        parse_error "unexpected argument $1, expecting -(v|c|ls|le|cs|ce|g|i), on line %line"
        ;;
    esac
  done
}


get_selected_token() {
  setvar "$1" $((${Tokens[index]}))
}

clear_tokens() {
  Tokens[length]=$((${Tokens[index]}-$1))
  if [ ${Tokens[index]} -gt ${Tokens[length]} ]; then
    Tokens[index]=${Tokens[length]}
  fi
}

clear_all_tokens() {
  unset Tokens
  declare -gA Tokens
  Tokens[index]=0
  Tokens[length]=0
}

move_back_token_index() {
  Tokens[index]=$((${Tokens[index]}-1))
}

forward_token() {
  Tokens[index]=$((${Tokens[index]}+1))
}

in_topmost_token() {
  [ ${Tokens[index]} = ${Tokens[length]} ]
}


mark_token_position() {
  TokenMark=${Tokens[index]}
}

return_token_to_mark() {
  Tokens[index]=$TokenMark
}



__shadowing_find_token_by() {
  local field="$1"
  local value="$2"
  local token="${Tokens[index]}"
  local tokenvar="$3"
  local tvalue

  while [ $token -ge 0 ]; do
    from_token $token $field tvalue
    if [[ "$tvalue" =~ ^$value$ ]]; then
      setvar "$tokenvar" $token
      return
    else
      token=$(($token-1))
    fi
  done
  setvar "$tokenvar" '-1'
}

find_token_by() {
  if [ -z ${__noshadow_2_+x} ]; then
    local __noshadow_2_
    local __noshadow_2_3
  fi
  __shadowing_find_token_by "$1" "$2"  __noshadow_2_3
  setvar "$3" "$__noshadow_2_3"
}


# FILE: lexer/tokens.bash
declare -gA States

States[index]=0

push_state() {
  States[${States[index]}]=$1
  States[index]=$((${States[index]}+1))
}

pop_state() {
  local index=$((${States[index]}-1))
  States[index]=$index
  setvar "$1" ${States[$index]}
}

in_topmost_state() {
  [ ${States[index]} = 1 ]
}

clear_states() {
  unset States
  declare -gA States
  States[index]=0
  push_state top
}

push_state top
# FILE: lexer/states.bash


# parse_token varname
# read a token from input and place it's id in the given variable
#
# e.g.
#
#  $ echo "abc" | {
#  > init_stream
#  > get_token token
#  > from_token $token value
#  > from_token $token class
#  > }
#  abc
#  name


__shadowing_parse_token() {
  local token_id_var="$1"   # variables where the token id will be stored

  local linenumber_start    # tokens store starting and ending line and collumn
  local linenumber_end      # numbers for debugging purposes.
  local collumn_start
  local collumn_end

  local state               # describes the parsing context, e.g. if in double quotes or parentheses
  local class=undefined     # token type
  local token=""            # token value
  local c=''                # character being parsed

  local move=true           # if true, the stream will move to the next character after the parsing of the current one.
  local skip_term=true      # if true, the terminating character will not be part of the next token

  local belongs=true        # if false, the current character does not belong to the current token and the latter is finished
  local next_state=none     # if not none, the current state and next state are pushed to the stack, in that order
  local next_class=none     # if not none, after finishing the current token, the next one will be given this class
  local state_end=false     # if true, the current state will be not be pushed in the stack at the end of parsing.

  local glued=true          # true if the token is glued to the previous one

  get_line_number linenumber_start
  get_collumn collumn_start

  # states are stored in a stack, to allow strings like 'a b$(echo c)d e'
  # to be handled by the lexer, where the tokens will be
  # 'a b', $(, echo, c, ), 'd e'.
  pop_state state

  # the token is done when its class is identified
  while [ $class = undefined ] && ! end_of_file; do
    get_character c

    case $state in
      quoted-escape)
        # if the escaped character is special, expand it before
        # putting it in the token, otherwise just put the character
        case "$c" in
          [bfnrtv]) printf -v token "%s\\$c" "$token" ;;
          *)        token="$token$c" ;;
        esac
        state=double-quotes
        ;;

      unquoted-escape)
        # for escaped spaces and newlines
        case "$c" in
          $'\n') ;;
          *) token="$token$c" ;;
        esac
        pop_state state
        ;;

      single-quotes)
        # accept all characters until an closing single quote is found
        if [ "$c" = "'" ]; then
          class=string
          state_end=true
        else
          token="$token$c"
        fi
        ;;

      double-quotes)
        # characters can be escaped, and expressions substituted in.
        # on substitutions, break the string and restart it after the
        # substitution is finished
        case "$c" in
          '\')
            state=quoted-escape
            ;;
          '$')
            class=string
            next_state=substitution
            ;;
          '"')
            class=string
            state_end=true
            ;;
          *)
            token="$token$c"
            ;;
        esac
        ;;

      whitespace)
        # indentation
        if [ "$c" = ' ' ]; then
          token="$token$c"
        else
          token=${#token}
          move=false
          class=whitespace
          state_end=true
        fi
        ;;

      substitution)
        token='$'
        class=special
        state_end=true
        move=false
        case "$c" in
          '(')
            token='$('
            move=true
            next_state=parentheses
            ;;
          '{')
            token='${'
            move=true
            next_state=curly-braces
            ;;

          [0-9a-zA-Z_]) next_state=variable ;;
          *)            class=name ;;
        esac
        ;;

      variable)
        case "$c" in
          [0-9a-zA-Z_])
            token="$token$c"
            ;;
          *)
            class=name
            state_end=true
            move=false
            ;;
        esac
        ;;

      comment)
        # ignore all until newline
        if [ "$c" = $'\n' ]; then
          token="$c"
          class=newline
          state_end=true
        fi
        ;;

      *)
        # all other contexts follow similar parsing rules,
        # the only difference being what token ends it
        case "$c" in
          "'"|'"'|'('|'['|'{')
            case "$c" in
              "'") next_state=single-quotes ;;
              '"') next_state=double-quotes ;;
              '(') next_state=parentheses;  skip_term=false; next_class=special ;;
              '[') next_state=brackets;     skip_term=false; next_class=special ;;
              '{') next_state=curly-braces; skip_term=false; next_class=special ;;
            esac
            belongs=false
            ;;

          ')'|']'|'}')
            if { { [ "$state" = parentheses  ] && [ ! "$c" = ')' ]; } ||
                 { [ "$state" = brackets     ] && [ ! "$c" = ']' ]; } ||
                 { [ "$state" = curly-braces ] && [ ! "$c" = '}' ]; } ;}; then
              parse_error "unexpected $c on line %line. ${state/-/ }"
            else
              belongs=false
              state_end=true
              skip_term=false
              next_class=special
            fi
            ;;

          ':'|';'|',')
            belongs=false
            skip_term=false
            next_class=special
            ;;

          '=')
            if [[ "$token" =~ [a-zA-Z_][a-zA-Z_0-9]* ]]; then
              belongs=false
              skip_term=false
              next_class=special
            else
              token="$token$c"
            fi
            ;;
          '\')
            state='unquoted-escape'
            ;;


          '$')
            belongs=false
            next_state=substitution
            skip_term=false
            ;;

          $'\n')
            [ -z "$token" ] && glued=false
            belongs=false
            next_class=newline
            ;;

          ' ')
            if line_start; then
              belongs=false
              skip_term=false
              next_state=whitespace
            elif [ -n "$token" ]; then
              belongs=false
            else
              glued=false
            fi
            ;;

          '#')
            belongs=false
            next_state=comment
            ;;

          *)
            token="$token$c"
            ;;
        esac
        if ! $belongs; then
          # found a terminating character while parsing
          if [ -z "$token" ]; then
            # if the current token is empty, don't return
            # any token, instead restart the loop.

            get_line_number linenumber_start # update starting position
            get_collumn collumn_start        #

            # we skip the terminating character by not
            # adding it to the current empty token
            if $skip_term; then
              token=""
            else
              token="$c"
              skip_term=true
            fi

            # having a next_class means the terminating character
            # forms a token on their own, e.g. '('. It will be
            # a single character token.
            if [ ! $next_class = none ]; then
              class=$next_class
            fi

            if [ ! $next_state = none ]; then
              push_state $state
              state=$next_state
              next_state=none
            fi
          else
            # if the token has any characters, return the token
            # and forget the terminating character.
            class=name
            state_end=false
            next_state=none

            move=false # ensures the terminating character is read again next call
          fi
        fi
        ;;
    esac
    $move && next_character
  done

  $state_end || push_state $state
  [ $next_state = none ] || push_state $next_state

  if end_of_file; then
    if in_topmost_state; then
      if [ -n "$token" ] && [ "$class" = unidentified ]; then
        class=name
      else
        token=eof
        class=eof
      fi
    else
      if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
        case "$state" in
          parentheses)  state='('; ;;
          brackets)     state='['; ;;
          curly-braces) state='{'; ;;
        esac
        POWSCRIPT_INCOMPLETE_STATE="$state"
        token=eof
        class=eof
      else
        unfinished_input_error "$state" "$linenumber_start" "$collumn_start"
      fi
    fi
  fi

  get_collumn collumn_end
  get_line_number linenumber_end

  store_token\
    "$token" "$class" "$glued"\
    "$linenumber_start" "$linenumber_end"\
    "$collumn_start" "$collumn_end"\
    "$token_id_var"
}

parse_token() {
  if [ -z ${__noshadow_3_+x} ]; then
    local __noshadow_3_
    local __noshadow_3_1
  fi
  __shadowing_parse_token  __noshadow_3_1
  setvar "$1" "$__noshadow_3_1"
}


get_token_id() {
  if in_topmost_token; then
    parse_token "$1"
  else
    get_selected_token "$1"
    forward_token
  fi
}

peek_token_id() {
  if in_topmost_token; then
    parse_token "$1"
    backtrack_token
  else
    get_selected_token "$1"
  fi
}

skip_token() {
  local _
  if in_topmost_token; then
    parse_token _
  else
    forward_token
  fi
}


get_token() {
  local __get_token__token
  get_token_id __get_token__token
  all_from_token "$@" $__get_token__token
}


peek_token() {
  local __peek_token__token
  peek_token_id __peek_token__token
  all_from_token "$@" $__peek_token__token
}


next_token_is() {
  local value class
  peek_token -v value -c class
  case $# in
    1)
      [ "$class" = "$1" ]
      ;;
    2)
      [[ "$class" = "$1" ]] && [[ "$value" = "$2" ]]
      ;;
  esac
}


token_ignore_whitespace() {
  if next_token_is whitespace; then
    skip_token
  fi
}


backtrack_token() {
  move_back_token_index
}


__shadowing_get_specific_token() {
  local value class required="$1" out="$2"
  get_token -v value -c class
  if [ ! $class = $required ]; then
    parse_error "Wrong token: found a $class of value $value when a $required was required"
  else
    setvar "$out" "$value"
  fi
}

get_specific_token() {
  if [ -z ${__noshadow_4_+x} ]; then
    local __noshadow_4_
    local __noshadow_4_2
  fi
  __shadowing_get_specific_token "$1"  __noshadow_4_2
  setvar "$2" "$__noshadow_4_2"
}


require_token() {
  local req_class="$1" req_value="$2"
  local value class

  get_token -v value -c class
  if [ ! "$req_class $req_value" = "$class $value" ]; then
    parse_error "Wrong token: found a $class of value $value when a $req_class of value $req_value was required"
  fi
}


unfinished_input_error() {
  local token
  local opener=
  local state="$1"
  local line
  local collumn
  case "$state" in
    parentheses)    opener='\$?\('  ;;
    brackets)       opener='\['     ;;
    curly-braces)   opener='\$?\{'  ;;
  esac
  if [ -n "$opener" ]; then
    find_token_by value "$opener" token
    if [ ! $token = -1 ]; then
      from_token $token linenumber_start line
      from_token $token collumn_start collumn
      parse_error "unclosed ${state/-/ }, last open one found in line $line, collumn $collumn"
    else
      parse_error "unclosed ${state/-/ }"
    fi
  else
    if [[ "$state" =~ quotes ]]; then
      line="$2"
      collumn="$3"
      parse_error "unfinished ${state/-/ }, starting in line $line, collumn $collumn"
    else
      parse_error "unexpected eof"
    fi
  fi
}

parse_error() {
  local message="error: ${1//%line/$(get_line_number)}"
  if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
    if ${POWSCRIPT_SHOW_INCOMPLETE_MESSAGE-false}; then
      >&2 echo "$message"
    fi
    POWSCRIPT_INCOMPLETE_STATE="$message"
    exit
  else
    >&2 echo "$message"
    exit 1
  fi
}

tokens_to_json() {
  local token
  init_stream

  echo '{'
  while ! end_of_file; do
    get_token -v value -c class -g glued
    from_token $token value value
    from_token $token class class
    from_token $token glued glued
    echo "  ${token}: {"
    echo "    'value': '$value'"
    echo "    'class': '$class'"
    echo "    'glued': $glued"
    echo '  }'
  done
  echo '}'
}
# FILE: lexer/lexer.bash
declare -gA Asts

Asts[index]=0
Asts[length]=0
Asts[required-indent]=0

declare -gA IndentStack

IndentStack[index]=0
IndentStack[starting-block]=false
IndentStack[0]=0


ast_new_indentation() {
  local indent

  ast_indentation_required indent

  ast_push_indentation $((indent+1))
  IndentStack[starting-block]=true
}



__shadowing_ast_test_indentation() {
  local value="$1" class="$2" out="$3"
  local req found result temp_result
  ast_indentation_required req
  ast_count_indentation "$value" $class found

  if ${IndentStack[starting-block]}; then
    if [ $found -ge $req ]; then
      IndentStack[starting-block]=false
      IndentStack[${IndentStack[index]}]=$found
      result=ok
    else
      result=error-start
    fi
  else
    if [ $found -eq $req ]; then
      result=ok

    elif [ $found -lt $req ]; then
      result=end
    else
      result=error-exact
    fi
  fi
  setvar "$out" $result
}

ast_test_indentation() {
  if [ -z ${__noshadow_5_+x} ]; then
    local __noshadow_5_
    local __noshadow_5_3
  fi
  __shadowing_ast_test_indentation "$1" "$2"  __noshadow_5_3
  setvar "$3" "$__noshadow_5_3"
}



ast_update_indentation() {
  IndentStack[${IndentStack[index]}]=$1
}

ast_pop_indentation() {
  IndentStack[index]=$((${IndentStack[index]}-1))
}

ast_push_indentation() {
  IndentStack[index]=$((${IndentStack[index]}+1))
  ast_update_indentation $1
}

ast_indentation_required() {
  setvar "$1" ${IndentStack[${IndentStack[index]}]}
}

ast_count_indentation() {
  case "$2" in
    whitespace) setvar "$3" "$1" ;;
    eof)        setvar "$3" -1   ;;
    *)          setvar "$3" 0    ;;
  esac
}

ast_indentation_layers() {
  setvar "$1" ${IndentStack[index]}
}

# FILE: ast/ast_indent.bash
declare -gA AstStates

AstStates[index]=0
AstStates[0]=top

ast_push_state() {
  local index=$((${AstStates[index]}+1))

  AstStates[index]=$index
  AstStates[$index]=$1
}

ast_pop_state() {
  AstStates[index]=$((${AstStates[index]}-1))
}

ast_last_state() {
  setvar "$1" "${AstStates[${AstStates[index]}]}"
}

ast_state_is() {
  local state
  ast_last_state state
  [ "$state" = "$1" ]
}

ast_clear_states() {
  unset AstStates
  declare -gA AstStates
  AstStates[index]=0
  AstStates[0]=top
}
# FILE: ast/ast_states.bash


__shadowing_new_ast() {
  local index="${Asts[index]}"
  local length="${Asts[length]}"

  setvar "$1" "$index"

  Asts[head-$index]=
  Asts[value-$index]=
  Asts[children-$index]=

  if [ ! $index = $length ]; then
    Asts[index]=$(($index+1))
  else
    Asts[index]=$(($length+1))
  fi
  Asts[length]=$(($length+1))
}

new_ast() {
  if [ -z ${__noshadow_6_+x} ]; then
    local __noshadow_6_
    local __noshadow_6_1
  fi
  __shadowing_new_ast  __noshadow_6_1
  setvar "$1" "$__noshadow_6_1"
}


make_ast() {
  local __newast __newchild
  new_ast __newast
  ast_set "$__newast" head  "$2"
  ast_set "$__newast" value "$3"
  for __newchild in ${@:4}; do
    ast_push_child "$__newast" $__newchild
  done
  setvar "$1" "$__newast"
}

from_ast() {
  setvar "$3" "${Asts["$2-$1"]}"
}

ast_set() {
  Asts["$2-$1"]="$3"
}

ast_set_to_overwrite() {
  Asts[index]="$1"
}

ast_is() {
  local ast_head ast_value
  from_ast $1 head  ast_head
  from_ast $1 value ast_value

  case $# in
    2)
      [ $ast_head = "$2" ]
      ;;
    3)
      [ $ast_head = "$2" ] && [ "$ast_value" = "$3" ]
      ;;
  esac
}


ast_push_child() {
  Asts["children-$1"]="${Asts["children-$1"]} $2"
}

ast_unshift_child() {
  Asts["children-$1"]="$2 ${Asts["children-$1"]}"
}


__shadowing_ast_children() {
  local ast="$1" ast_children children_array child i
  from_ast $ast children ast_children
  children_array=( $ast_children )

  i=0
  for child_name in ${@:2}; do
    setvar "$child_name" ${children_array[$i]}
    i=$((i+1))
  done
}

ast_children() {
  if [ -z ${__noshadow_7_+x} ]; then
    local __noshadow_7_
    declare -A __noshadow_7_all
          for __noshadow_7_n in $(seq 2 $#); do
            __noshadow_7_all[$__noshadow_7_n]=__noshadow_7_$__noshadow_7_n
          done
  fi
  __shadowing_ast_children "$1"  "${__noshadow_7_all[@]}"
  #
          shift 0
          for __noshadow_7_n in $(seq 2 $#); do
            setvar "$2" "${!__noshadow_7_all[$__noshadow_7_n]}"
            shift
          done
}



ast_clear() {
  unset Asts["value-$1"]
  unset Asts["head-$1"]
  unset Asts["children-$1"]
}

ast_clear_all() {
  unset Asts
  declare -gA Asts

  Asts[index]=0
  Asts[length]=0
  Asts[required-indent]=0
}

ast_print() {
  printf '`'
  ast_print_child "$1" "$2"
  echo '`'
}

ast_print_child() {
  local ast=$1 indent=
  local ast_head ast_value ast_children
  from_ast $ast head     ast_head
  from_ast $ast value    ast_value
  from_ast $ast children ast_children

  local child_array=( $ast_children )

  case $ast_head in
    name)
      printf "%s" "$ast_value"
      ;;
    cat)
      local child
      for child in ${child_array[@]:0:$((${#child_array[@]}-1))}; do
        ast_print_child $child
      done
      ast_print_child ${child_array[${#child_array[@]}-1]}
      ;;
    string)
      printf "'%s'" "$ast_value"
      ;;
    call)
      local command=${child_array[0]}
      local argument

      ast_print_child $command
      for argument in ${child_array[@]:1}; do
        printf ' '
        ast_print_child $argument
      done
      ;;
    assign)
      local name=${child_array[0]} value=${child_array[1]}
      ast_print_child $name
      printf '='
      ast_print_child $value
      ;;
    indexing-assign)
      local name=${child_array[0]} index=${child_array[1]} value=${child_array[2]}
      ast_print_child $name
      printf '['
      ast_print_child $index
      printf ']='
      ast_print_child $value
      ;;
    simple-substitution)
      printf '$%s' "$ast_value"
      ;;
    indexing-substitution)
      printf '${%s[' "$ast_value"
      ast_print_child ${child_array[0]}
      printf ']}'
      ;;
    command-substitution)
      printf '$('
      ast_print_child ${child_array[0]}
      printf ')'
      ;;
    function-def)
      local name=${child_array[0]} args=${child_array[1]} block=${child_array[2]}

      ast_print_child $name
      ast_print_child $args
      echo
      ast_print_child $block
      ;;
    list)
      local element

      printf '( '
      for element in "${child_array[@]}"; do
        ast_print_child $element
        printf ' '
      done
      printf ')'
      ;;

    block)
      local statement

      for statement in "${child_array[@]}"; do
        printf "%$((ast_value*2)).s" ''
        ast_print_child $statement
        echo
      done
      ;;
  esac
}

# FILE: ast/ast_heap.bash


# try_parse_ast
#
# try parsing an ast expression from the input,
# printing 'top' on success or the last
# parser state on failure.

try_parse_ast() {
  (
    local ast
    POWSCRIPT_INCOMPLETE_STATE=

    trap '
      if [ -n "$POWSCRIPT_INCOMPLETE_STATE" ]; then
        echo "$POWSCRIPT_INCOMPLETE_STATE"
      else
        ast_last_state
      fi
      exit' EXIT

    POWSCRIPT_ALLOW_INCOMPLETE=true parse_ast ast
    exit
  )
}

# parse_ast $out
#
# parse an ast expression form the input,
# storing it in $out.

parse_ast() {
  parse_ast_linestart "$1"
}

ast_error() {
  local message="$1"

  if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
    POWSCRIPT_INCOMPLETE_STATE="error: $message"
    if ${POWSCRIPT_SHOW_INCOMPLETE_MESSAGE-false}; then
      >&2 echo "$message"
    fi
  else
    >&2 echo "$message"
  fi
  exit
}

# parse_ast_linestart $out
#
# test that there is no indentation before proceeding
# to parse the expression.


__shadowing_parse_ast_linestart() {
  local value class line

  get_token -v value -c class -ls line

  if [ "$class" = whitespace ]; then
    ast_error "indentation error at line $line, unexpected indentation of $value."
  else
    backtrack_token
    parse_ast_top "$1"
  fi
}

parse_ast_linestart() {
  if [ -z ${__noshadow_8_+x} ]; then
    local __noshadow_8_
    local __noshadow_8_1
  fi
  __shadowing_parse_ast_linestart  __noshadow_8_1
  setvar "$1" "$__noshadow_8_1"
}



# parse_ast_top $out
#
# analyze first expression and dispatch to the
# appropriate function based on it.


__shadowing_parse_ast_top() {
  local out="$1"
  local expr expr_head

  parse_ast_expr expr
  from_ast $expr head expr_head

  case $expr_head in
    name)
      local expr_value
      from_ast $expr value expr_value
      case "$expr_value" in
        'if')      parse_ast_if 'if' "$out" ;;
        'while')   parse_ast_while   "$out" ;;
        'switch')  parse_ast_switch  "$out" ;;
        'require') parse_ast_require "$out" ;;
        *)
          if next_token_is special '('; then
            parse_ast_function_definition $expr "$out"
          else
            parse_ast_commandcall $expr "$out"
          fi
          ;;
      esac
      ;;
    assign|indexing-assign)
      setvar "$out" $expr
      ;;
    newline)
      setvar "$out" -1
      ;;
    *)
      parse_ast_commandcall $expr "$out"
      ;;
  esac
}

parse_ast_top() {
  if [ -z ${__noshadow_9_+x} ]; then
    local __noshadow_9_
    local __noshadow_9_1
  fi
  __shadowing_parse_ast_top  __noshadow_9_1
  setvar "$1" "$__noshadow_9_1"
}



# parse_ast_expr $out
#
# basic expression, which can be a name,
# string, substitution or concatenation.


__shadowing_parse_ast_expr() {
  local out="$1"
  local value class glued
  local root root_head=undefined
  local expression exprnum=0 last_expression

  new_ast root

  while [ $root_head = undefined ]; do
    token_ignore_whitespace
    get_token -v value -c class -g glued

    if $glued || [ $exprnum = 0 ]; then
      case $class in
        name|string)
          make_ast expression $class "$value"
          ;;
        special)
          case "$value" in
            '$')
              parse_ast_substitution expression
              ;;

            '${')
              parse_ast_curly_substitution expression
              ;;

            '$(')
              parse_ast_command_substitution expression
              ;;

            '(')
              if [ $exprnum -gt 0 ]; then
                root_head=determinable
              else
                ast_push_state '('
                parse_ast_list root
                root_head=list
                ast_pop_state
              fi
              ;;

            ')'|']'|'}')
              local opener
              case $value in
                ')') opener='('; ;;
                ']') opener='['; ;;
                '}') opener='{'; ;;
              esac
              if ast_state_is $opener; then
                root_head=determinable
              else
                make_ast expression string "$value"
              fi
              ;;

            '=')
              if [ $exprnum = 1 ] && ast_is $last_expression name; then
                parse_ast_expr expression
                ast_push_child $root $expression
                root_head=assign
              else
                make_ast expression string "="
              fi
              ;;
            '[')
              if [ $exprnum = 1 ] && ast_is $last_expression name; then
                local index
                ast_push_state '['
                parse_ast_expr index

                require_token special ']'
                ast_pop_state

                if next_token_is special '=' && ast_is $index name; then
                  skip_token
                  parse_ast_expr expression
                  root_head=indexing-assign
                  ast_push_child $root $index
                  ast_push_child $root $expression
                else
                  local left_bracket right_bracket
                  make_ast left_bracket  name '['
                  make_ast right_bracket name ']'

                  ast_push_child $root $left_bracket
                  ast_push_child $root $index

                  expression=$right_bracket
                  exprnum=3
                fi
              else
                make_ast expression string "["
              fi
              ;;

            *)
              make_ast expression name "$value"
              ;;
          esac
          ;;
        newline|eof)
          root_head=$class
          ;;
        *)
          ast_error "token of class $class found when parsing an expression ast"
          ;;
      esac

      if [ $root_head = undefined ]; then
        ast_push_child $root $expression
        exprnum=$((exprnum+1))
        last_expression=$expression
      fi
    else
      root_head=determinable
    fi

    if [ $root_head = determinable ]; then
      if [ $exprnum = 1 ]; then
        ast_clear $root
        root=$last_expression
        from_ast $root head root_head
      else
        root_head=cat
      fi
      backtrack_token
    fi
  done
  ast_set $root head $root_head
  #>&2 echo "$(ast_print $root) :: $(from_ast $root head)"

  setvar "$out" $root
}

parse_ast_expr() {
  if [ -z ${__noshadow_10_+x} ]; then
    local __noshadow_10_
    local __noshadow_10_1
  fi
  __shadowing_parse_ast_expr  __noshadow_10_1
  setvar "$1" "$__noshadow_10_1"
}


parse_ast_expr_and_set() {
  local __paeas_expr
  parse_ast_expr __paeas_expr

  while [ $# -gt 0 ]; do
    case "$1" in
      -e|--expr)
        setvar "$2" $__paeas_expr
        shift 2
        ;;
      -v|--value)
        from_ast $__paeas_expr value "$2"
        shift 2
        ;;
      -h|--head)
        from_ast $__paeas_expr head "$2"
        shift 2
        ;;
      -c|--children)
        from_ast $__paeas_expr children "$2"
        shift 2
        ;;
      -@|--@children)
        ast_children $__paeas_expr "${@:2}"
        shift $#
        ;;
      *)
        ast_error "Invalid flag $1, expected -[evhc@]"
        ;;
    esac
  done
}


__shadowing_parse_ast_specific_expr() {
  local expr expr_head required="$1" out="$2"
  parse_ast_expr expr
  from_ast $expr head expr_head

  if [ $expr_head = $required ]; then
    setvar "$out" $expr
  else
   ast_error "Wrong expression: Found a $expr_head when a $required was required"
 fi
}

parse_ast_specific_expr() {
  if [ -z ${__noshadow_11_+x} ]; then
    local __noshadow_11_
    local __noshadow_11_2
  fi
  __shadowing_parse_ast_specific_expr "$1"  __noshadow_11_2
  setvar "$2" "$__noshadow_11_2"
}



__shadowing_parse_ast_substitution() {
  local subst out="$1"
  local expr value head varname index lb rb aft
  local cat_children cat_array

  parse_ast_expr_and_set -e expr -v value -h head -@ varname lb index rb aft

  case "$head" in
    name)
      make_ast subst simple-substitution "$value"
      ;;
    cat)
       if ast_is $lb name '['; then
         from_ast $varname value value
         make_ast subst indexing-substitution "$value" $index
         if [ -n "$aft" ]; then
           from_ast $expr children cat_children
           cat_array=( $cat_children )
           make_ast subst cat $subst "${cat_array[@:4]}"
         fi
       else
         subst=$expr
       fi
      ;;
    *)
      ast_error "unimplemented"
      ;;
  esac
  setvar "$out" $subst
}

parse_ast_substitution() {
  if [ -z ${__noshadow_12_+x} ]; then
    local __noshadow_12_
    local __noshadow_12_1
  fi
  __shadowing_parse_ast_substitution  __noshadow_12_1
  setvar "$1" "$__noshadow_12_1"
}



__shadowing_parse_ast_curly_substitution() {
  local out="$1"
  local subst head

  ast_push_state '{'
  parse_ast_expr_and_set -e subst -h head

  case "$head" in
    *substitution)
      require_token special '}'
      ast_pop_state
      ;;
    *)
      ast_error "unimplemented"
      ;;
  esac

  setvar "$out" $subst
}

parse_ast_curly_substitution() {
  if [ -z ${__noshadow_13_+x} ]; then
    local __noshadow_13_
    local __noshadow_13_1
  fi
  __shadowing_parse_ast_curly_substitution  __noshadow_13_1
  setvar "$1" "$__noshadow_13_1"
}



__shadowing_parse_ast_command_substitution() {
  local out="$1"
  local cmd call

  make_ast "$out" command-substitution ''

  ast_push_state '$('
  parse_ast_expr cmd
  parse_ast_commandcall $cmd call
  ast_pop_state

  ast_push_child "${!out}" $call
}

parse_ast_command_substitution() {
  if [ -z ${__noshadow_14_+x} ]; then
    local __noshadow_14_
    local __noshadow_14_1
  fi
  __shadowing_parse_ast_command_substitution  __noshadow_14_1
  setvar "$1" "$__noshadow_14_1"
}



# parse_ast_commandcall $command $out
#
# parse a command call, consisting of
# a command and a series of space
# separated arguments


__shadowing_parse_ast_commandcall() {
  local command_ast=$1 out="$2"
  local expression child expr_head=none

  make_ast expression call '' $command_ast

  parse_ast_arguments $expression

  setvar "$out" $expression
}

parse_ast_commandcall() {
  if [ -z ${__noshadow_15_+x} ]; then
    local __noshadow_15_
    local __noshadow_15_2
  fi
  __shadowing_parse_ast_commandcall "$1"  __noshadow_15_2
  setvar "$2" "$__noshadow_15_2"
}


parse_ast_arguments() {
  local expr="$1"
  local expr_head=none expr_value child unfinished=true state state_s

  ast_last_state state
  case $state in
    '$(')
      state_s='c'
      ;;
    top)
      state_s='t'
      ;;
    '==')
      state_s='i'
      ;;
    *)
      state_s='o'
      ;;
  esac


  while $unfinished; do
    parse_ast_expr child
    from_ast $child head expr_head

    case "$state_s/$expr_head" in
      'c/command-substitution-end'|[ti]'/eof'|[oti]'/newline')
        unfinished=false
        ;;

      'i/name')
        from_ast $child value expr_value

        case "$expr_value" in
          or|and|'&&'|'||') unfinished=false; ;;
          *) ast_push_child $expr $child; ;;
        esac
        ;;

      *eof)
        if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
          POWSCRIPT_INCOMPLETE_STATE=$state
          exit
        else
          ast_error "unexpected end of file while parsing command."
        fi
        ;;

      *newline)
        ;;

      *)
        ast_push_child $expr $child
        ;;
    esac
  done
}


# parse_ast_if $block_type $out
#
# parses a if statement, which is
# a conditional expression, followed
# by a newline, block, and possibly an
# else or elif statements


__shadowing_parse_ast_if() {
  local block_type=$1 out="$2"
  local expr conditional block

  new_ast expr
  ast_set $expr head 'if'

  parse_ast_conditional conditional
  parse_ast_require_newline "condition in if statement"
  parse_ast_block $block_type block

  ast_push_child $expr $conditional
  ast_push_child $expr $block

  parse_ast_post_if $expr

  setvar "$out" $expr
}

parse_ast_if() {
  if [ -z ${__noshadow_16_+x} ]; then
    local __noshadow_16_
    local __noshadow_16_2
  fi
  __shadowing_parse_ast_if "$1"  __noshadow_16_2
  setvar "$2" "$__noshadow_16_2"
}


parse_ast_post_if() {
  local if_ast="$1"
  local value class clause_type

  peek_token -v value -c class
  if [ $class = whitespace ]; then
    skip_token
    peek_token -v value -c class
    backtrack_token
  fi

  if [ $class = name ]; then
    clause_type="$value"
  else
    clause_type=none
  fi

  case "$clause_type" in
    else)
      local else_ast else_block
      make_ast else_ast else

      token_ignore_whitespace
      skip_token
      parse_ast_require_newline "else statement"
      parse_ast_block el else_block

      ast_push_child $else_ast $else_block
      ast_push_child $if_ast $else_ast
      ;;
    elif)
      local elif_ast
      token_ast_ignore_whitespace
      skip_token
      parse_ast_if elif_ast ef

      ast_push_child $if_ast $elif_ast
      ;;
    *)
      local end_ast
      new_ast end_ast
      ast_set $end_ast head end_if

      ast_push_child $if_ast $end_ast
      ;;
  esac
}


__shadowing_parse_ast_conditional() {
  local out="$1"
  local condition
  local initial initial_head initial_value

  parse_ast_expr initial

  from_ast $initial head  initial_head
  from_ast $initial value initial_value

  if [ "$initial_head $initial_value" = "name not" ]; then
    parse_ast_negated_conditional condition
  else
    local value class is_command=true

    peek_token -v value -c class

    if [ $class = name ]; then
      case "$value" in
        is|isnt|'>'|'<'|'<='|'>='|'!='|'='|match)
          is_command=false
          skip_token
          ;;
      esac
    fi

    if $is_command; then
      parse_ast_command_conditional $initial condition
    else
      local left=$initial right
      parse_ast_expr right
      make_ast condition condition $value $left $right
    fi
  fi
  parse_ast_composite_conditional $condition condition

  setvar "$out" $condition
}

parse_ast_conditional() {
  if [ -z ${__noshadow_17_+x} ]; then
    local __noshadow_17_
    local __noshadow_17_1
  fi
  __shadowing_parse_ast_conditional  __noshadow_17_1
  setvar "$1" "$__noshadow_17_1"
}




__shadowing_parse_ast_negated_conditional() {
  local condition out="$1"

  ast_push_state '!'
  parse_ast_conditional condition
  ast_pop_state

  make_ast "$out" condition not $condition
}

parse_ast_negated_conditional() {
  if [ -z ${__noshadow_18_+x} ]; then
    local __noshadow_18_
    local __noshadow_18_1
  fi
  __shadowing_parse_ast_negated_conditional  __noshadow_18_1
  setvar "$1" "$__noshadow_18_1"
}




__shadowing_parse_ast_command_conditional() {
  local cmd="$1" cmd_ast out="$2"

  ast_push_state '=='
  parse_ast_commandcall $cmd cmd_ast
  ast_pop_state

  make_ast "$out" condition 'command' $cmd_ast
  backtrack_token
}

parse_ast_command_conditional() {
  if [ -z ${__noshadow_19_+x} ]; then
    local __noshadow_19_
    local __noshadow_19_2
  fi
  __shadowing_parse_ast_command_conditional "$1"  __noshadow_19_2
  setvar "$2" "$__noshadow_19_2"
}




__shadowing_parse_ast_composite_conditional() {
  local value class success=false condition_left="$1" condition_right out="$2"
  peek_token -v value -c class

  if [ "$class" = name ]; then
    case "$value" in
      "and"|"or"|"&&"|"||")
        if ! ast_state_is '!'; then
          skip_token
          parse_ast_conditional condition_right
          success=true
        elif [[ "$value" =~ ('&&'|'||') ]]; then
          skip_token
          parse_ast_negated_conditional condition_right
          success=true
        fi
      ;;
    esac
  fi
  if $success; then
    make_ast "$out" condition $value $condition_left $condition_right
  else
    setvar "$out" $condition_left
  fi
}

parse_ast_composite_conditional() {
  if [ -z ${__noshadow_20_+x} ]; then
    local __noshadow_20_
    local __noshadow_20_2
  fi
  __shadowing_parse_ast_composite_conditional "$1"  __noshadow_20_2
  setvar "$2" "$__noshadow_20_2"
}



__shadowing_parse_ast_function_definition() {
  local name=$1 out="$2"
  local expr args block

  make_ast expr function-def

  parse_ast_specific_expr list args
  parse_ast_require_newline "function definition"
  parse_ast_block fn block

  ast_push_child $expr $name
  ast_push_child $expr $args
  ast_push_child $expr $block

  setvar "$out" $expr
}

parse_ast_function_definition() {
  if [ -z ${__noshadow_21_+x} ]; then
    local __noshadow_21_
    local __noshadow_21_2
  fi
  __shadowing_parse_ast_function_definition "$1"  __noshadow_21_2
  setvar "$2" "$__noshadow_21_2"
}


parse_ast_require_newline() {
  local nl nl_head
  parse_ast_expr nl
  from_ast $nl head nl_head
  case $nl_head in
    newline)
      ;;
    eof)
      if ! ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
        ast_error "unexpected end of file after $1"
      fi
      ;;
    *)
      ast_error "trailing expression after ${1}: $(ast_print $nl) :: $(from_ast $nl head)"
      ;;
  esac
}


__shadowing_parse_ast_block() {
  local state=$1 out="$2"
  local expr child indent_state indent_layers
  local value class token_line ln="0"

  new_ast expr
  ast_set $expr head block

  ast_push_state $state
  ast_new_indentation

  ast_indentation_layers indent_layers
  ast_set $expr value $indent_layers

  indent_state=ok

  while [ ! $indent_state = end ]; do
    peek_token -v value -c class -ls token_line

    ast_test_indentation "$value" $class indent_state

    case $indent_state in
      ok)
        parse_ast_top child
        if [ ! "$child" = -1 ]; then
          ast_push_child $expr $child
          ln="$token_line"
        fi
        ;;
      error*)
        if [ $class = eof ] && ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
          POWSCRIPT_INCOMPLETE_STATE="$(ast_last_state)"
          exit
        fi

        local req found or_more=""
        [ $indent_state = error-start ] && or_more=" or more"

        ast_indentation_required req
        ast_count_indentation "$value" $class found
        ast_error "$indent_state : indentation error at line $token_line, expected $req spaces$or_more, found $found."
        ;;
    esac
  done

  ast_pop_state
  ast_pop_indentation
  setvar "$out" $expr
}

parse_ast_block() {
  if [ -z ${__noshadow_22_+x} ]; then
    local __noshadow_22_
    local __noshadow_22_2
  fi
  __shadowing_parse_ast_block "$1"  __noshadow_22_2
  setvar "$2" "$__noshadow_22_2"
}





__shadowing_parse_ast_list() {
  local out="$1"
  local expr child open=true
  local class value

  new_ast expr
  ast_set $expr head list

  while $open; do
    peek_token -v value -c class
    case "$class $value" in
      'special )')
        open=false
        skip_token
        ;;
      'newline '*)
        skip_token
        ;;
      'eof '*)
        if ${POWSCRIPT_ALLOW_INCOMPLETE-false}; then
          POWSCRIPT_INCOMPLETE_STATE="$(ast_last_state)"
          exit
        else
          ast_error "end of file while parsing list"
        fi
        ;;
      *)
        parse_ast_expr child
        ast_push_child $expr $child
        ;;
    esac
  done
  setvar "$out" $expr
}

parse_ast_list() {
  if [ -z ${__noshadow_23_+x} ]; then
    local __noshadow_23_
    local __noshadow_23_1
  fi
  __shadowing_parse_ast_list  __noshadow_23_1
  setvar "$1" "$__noshadow_23_1"
}


# FILE: ast/ast.bash
declare -gA PowscriptBackends

bash_interactive() {
  local wfifo="$1"
  local rfifo="$2"
  local end="$3"
  local code="__PowscriptCompiledCode__"
  local line="__PowscriptCodeLine__"
  local result="__PowscriptResultLine__"
  bash -c "
    trap 'echo \"#<<END.$end>>\" >>\"$rfifo\"' EXIT
    $code=
    $line=
    $result=
    while true; do
      IFS= read -r $line <'$wfifo'
      if [ \"\$$line\" = '#<<END>>' ] ; then
        2>&1 eval \"\$$code\" >>'$rfifo'
        echo '#<<END.$end>>' >>'$rfifo'
        $code=
      else
        $code=\"\$$code\"\$'\n'\"\$$line\"
      fi
    done
  " 2>/dev/null
}

# FILE: lang/bash/interactive.bash


__shadowing_bash_compile() {
  local expr=$1 out="$2"
  local expr_head expr_value expr_children

  from_ast $expr head expr_head

  case "$expr_head" in
    name)
      from_ast $expr value "$out"
      ;;

    string)
      from_ast $expr value expr_value
      setvar "$out" "'$expr_value'"
      ;;

    cat)
      local child compiled result=""
      from_ast $expr children expr_children
      for child in $expr_children; do
        bash_compile $child compiled
        result="$result$compiled"
      done
      setvar "$out" "$result"
      ;;

    if|elif)
      local expr_children
      local condition block post_if

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} condition
      bash_compile ${expr_children[1]} block
      bash_compile ${expr_children[2]} post_if

      setvar "$out" "$expr_head $condition; then"$'\n'"${block:2:$((${#block}-4))}"$'\n'"$post_if"
      ;;
    else)
      local expr_children
      local block

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} block

      setvar "$out" "else"$'\n'"${block:2:$((${#block}-4))}"$'\n'"fi"
      ;;

    end_if)
      setvar "$out" "fi"
      ;;

    simple-substitution)
      local name
      from_ast $expr value name
      setvar "$out" "\"\${$name}\""
      ;;

    indexing-substitution)
      local name index expr_children

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      from_ast $expr value name
      bash_compile ${expr_children[0]} index

      setvar "$out" "\"\${$name[$index]}\""
      ;;
    command-substitution)
      local call_ast call

      from_ast $expr children call_ast

      bash_compile $call_ast call

      setvar "$out" '$('"$call"')'
      ;;

    call)
      local command argument compiled result
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} result

      for argument in ${expr_children[@]:1}; do
        bash_compile $argument compiled
        result="$result $compiled"
      done
      setvar "$out" "$result"
      ;;

    assign)
      local name value
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} name
      bash_compile ${expr_children[1]} value

      setvar "$out" "$name=$value"
      ;;

    indexing-assign)
      local name index value
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} name
      bash_compile ${expr_children[1]} index
      bash_compile ${expr_children[2]} value

      setvar "$out" "$name[$index]=$value"
      ;;
    list)
      local expr_children child_ast child result

      from_ast $expr children expr_children

      result="( "
      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result$child "
      done

      setvar "$out" "$result)"
      ;;

    function-def)
      local name args_ast arg_assign_ast argval_ast block_ast block
      local args arg argval argnum locals_ast argname_ast

      from_ast $expr children expr_children
      expr_children=( $expr_children )

      bash_compile ${expr_children[0]} name

      args_ast=${expr_children[1]}
      block_ast=${expr_children[2]}


      new_ast locals_ast
      ast_set $locals_ast head local

      from_ast $args_ast children args


      argnum=1
      for arg in $args; do
        make_ast argval_ast simple-substitution $argnum
        make_ast arg_assign_ast assign '' $arg $argval_ast
        ast_push_child $locals_ast $arg_assign_ast
        argnum=$((argnum+1))
      done
      ast_unshift_child $block_ast $locals_ast

      bash_compile $block_ast block

      setvar "$out" "$name() $block"
      ;;

    local)
      local result="local" child_ast child
      from_ast $expr children expr_children

      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result $child"
      done

      setvar "$out" "$result"
      ;;
    block)
      local child_ast child result
      from_ast $expr children expr_children

      result='{'
      for child_ast in $expr_children; do
        bash_compile $child_ast child
        result="$result"$'\n'"$child"
      done
      result="$result"$'\n}'

      setvar "$out" "$result"
      ;;

    condition)
      local op left right quoted=no
      from_ast $expr value op
      from_ast $expr children expr_children
      expr_children=( $expr_children )

      case "$op" in
        command)
          bash_compile ${expr_children[0]} left
          setvar "$out" "$left"
          ;;
        not)
          bash_compile ${expr_children[0]} right
          setvar "$out" "! $right"
          ;;
        *)
          bash_compile ${expr_children[0]} left
          bash_compile ${expr_children[1]} right

          case "$op" in
            'is'|'=')     op='='    quoted=single ;;
            'isnt'|'!=')  op='!='   quoted=single ;;
            '>')          op='-gt'  quoted=single ;;
            '>=')         op='-ge'  quoted=single ;;
            '<')          op='-lt'  quoted=single ;;
            '<=')         op='-le'  quoted=single ;;
            'match')      op='=~'   quoted=double ;;
            'and'|'&&')   op='&&' ;;
            'or'|'||')    op='||' ;;
          esac

          case $quoted in
            double) setvar "$out" "[[ $left $op $right ]]" ;;
            single) setvar "$out"  "[ $left $op $right ]"  ;;
            no)     setvar "$out"    "$left $op $right"    ;;
          esac
          ;;
      esac
      ;;
  esac
}

bash_compile() {
  if [ -z ${__noshadow_24_+x} ]; then
    local __noshadow_24_
    local __noshadow_24_2
  fi
  __shadowing_bash_compile "$1"  __noshadow_24_2
  setvar "$2" "$__noshadow_24_2"
}

# FILE: lang/bash/compile.bash
# FILE: lang/sh/compile.bash

select_backend() {
  eval "
    compile_to_backend () { ${1}_compile \"\$@\"; }
    interactive_compile_target () { ${1}_interactive \"\$@\"; }
  "
}

# FILE: lang/backends.bash

PowscriptTempDirectory="$(mktemp -d --suffix=".powscript")"

powscript_temp_name() {
  local suffix=".powscript$1"
  setvar "$2" "$(mktemp -u --suffix="$suffix" -p "$PowscriptTempDirectory")"
}

powscript_make_temp() {
  powscript_temp_name "$1" "$2"
  touch "${!2}"
}

powscript_make_fifo() {
  powscript_temp_name "$1" "$2"
  mkfifo "${!2}"
}

powscript_clean_up() {
  [ -d "$PowscriptTempDirectory" ] && rm -r "$PowscriptTempDirectory"
  [ -n "$PowscriptGuestProcess"  ] && ps -p "$PowscriptGuestProcess" >/dev/null && kill STOP "$PowscriptGuestProcess"
  exit 0
}

trap 'powscript_clean_up' ERR EXIT

# FILE: compiler/temp.bash
PowscriptBackend=bash
PowscriptInteractiveMode=nofile
PowscriptCompileFile=false
PowscriptOutput='/dev/stdout'

declare -gA PowscriptFiles
PowscriptFileNumber=0

powscript_parse_options() {
  while [ "$#" -gt 0 ]; do
    case "$1" in
      '-o'|'--output')
        PowscriptOutput="$2"
        shift 2
        ;;
      '-i'|'--interactive')
        PowscriptInteractiveMode=yes
        shift
        ;;
      '-d'|'--debug')
        PowscriptInteractiveMode=false
        PowscriptCompileFile=false
        shift $#
        ;;
      '--to')
        shift
        case "$1" in
          bash|sh)
            PowscriptBackend="$1"
            ;;
          *)
            >&2 echo "Invalid powscript backend $1"
            exit 1
            ;;
        esac
        ;;
      '-c'|'--compile')
        PowscriptCompileFile=true
        shift
        ;;

      '-'*)
        >&2 echo "Invalid powscript option $1"
        exit 1
        ;;

      *)
        PowscriptFiles[$PowscriptFileNumber]="$1"
        PowscriptFileNumber=$((PowscriptFileNumber+1))
        shift
        ;;
    esac
  done

  if $PowscriptCompileFile && [ "$PowscriptFileNumber" -eq 0 ]; then
    >&2 echo "No input files given"
  fi

  case $PowscriptInteractiveMode in
    no)  PowscriptInteractiveMode=false; ;;
    yes) PowscriptInteractiveMode=true; ;;
    nofile)
      if [ "$PowscriptFileNumber" -gt 0 ]; then
        PowscriptInteractiveMode=false
      else
        PowscriptInteractiveMode=true
      fi
      ;;
  esac
}

powscript_is_interactive() {
  $PowscriptInteractiveMode
}
# FILE: compiler/options.bash
powscript_compile_file() {
  local output=${1-/dev/stdout}
  local ast

  init_stream
  clear_compilation
  while ! end_of_file; do
    parse_ast ast
    compile_to_backend $ast >$output
  done
}

# FILE: compiler/files.bash
InteractiveFileLineNumber=0

interactive_mode() {
  local ast code compiled_code line="" state=none
  local proc rfifo wfifo end_token result
  local powhistory="${POWSCRIPT_HISTORY_FILE-$HOME/.powscript_history}"
  local extra_line=''
  local compile_flag=false ast_flag=false echo_flag=false incomplete_flag=false

  [ ! -f "$powhistory" ] && echo >"$powhistory"
  history -c
  history -r "$powhistory"

  powscript_make_fifo ".interactive.wfifo" wfifo
  powscript_make_fifo ".interactive.rfifo" rfifo
  powscript_temp_name ".end" end_token

  interactive_compile_target "$wfifo" "$rfifo" "$end_token" &
  proc="$!"
  PowscriptGuestProcess="$proc"

  exec 3<>"$wfifo"
  exec 4<>"$rfifo"

  while ps -p $proc >/dev/null; do
    result=

    if [ -n "${extra_line// /}" ]; then
      line="$extra_line"
      extra_line=""
    else
      read_powscript top line
    fi
    code="$line"

    case "$code" in
      '.compile')
        toggle_flag compile_flag
        ;;
      '.ast')
        toggle_flag ast_flag
        ;;
      '.echo')
        toggle_flag echo_flag
        ;;
      '.incomplete')
        toggle_flag incomplete_flag
        ;;
      '.show '*)
        show_ast "${code//.show /}"
        echo
        ;;
      *)
        state=none
        while [ ! "$state" = top ]; do
          clear_compilation
          state="$( { init_stream; POWSCRIPT_SHOW_INCOMPLETE_MESSAGE=$incomplete_flag try_parse_ast; } <<< "$code" )"
          case "$state" in
            top)
              clear_compilation
              { init_stream; parse_ast ast; } <<< "$code"$'\n'
              ;;
            error*)
              >&2 echo "$state"
              state=none
              code=
              line=
              ;;
            *)
              read_powscript "$state" line
              code="$code"$'\n'"$line"
              ;;
          esac
        done
        if ! end_of_file; then
          get_remaining_input extra_line
          code="${code:0:$(($# - ${#extra_line}))}"
        fi

        history -s "$code"

        if $echo_flag; then
          echo "---- CODE ECHO -----"
          echo "$code"
          echo "---------------------"
         fi

        if $ast_flag; then
          echo "---- SYNTAX TREE ----"
          show_ast $ast
          echo "---------------------"
        fi
        compile_to_backend $ast compiled_code
        if $compile_flag; then
          echo "--- COMPILED CODE ---"
          echo "$compiled_code"
          echo "---------------------"
        fi
        echo "$compiled_code" >>"$wfifo"
        echo "#<<END>>" >>"$wfifo"
        while [ ! "$result" = "#<<END.$end_token>>" ]; do
          IFS= read -r result <"$rfifo"
          [ ! "$result" = "#<<END.$end_token>>" ] && echo "$result"
        done
        echo
        ;;
    esac
  done
  history -w "$powhistory"

  [ -p "$wfifo" ] && rm $wfifo
  [ -p "$rfifo" ] && rm $rfifo
}


__shadowing_get_remaining_input() {
  local collumn out="$1"
  peek_token -cs collumn <<< ""
  jump_to_collumn $collumn
  get_rest_of_line "$out"
}

get_remaining_input() {
  if [ -z ${__noshadow_25_+x} ]; then
    local __noshadow_25_
    local __noshadow_25_1
  fi
  __shadowing_get_remaining_input  __noshadow_25_1
  setvar "$1" "$__noshadow_25_1"
}


clear_compilation() {
  clear_all_tokens
  clear_states
  ast_clear_all
  ast_clear_states
}

show_ast() {
  echo "id:       $1"
  echo "head:     $(from_ast $1 head)"
  echo "value:    $(from_ast $1 value)"
  echo "children: $(from_ast $1 children)"
  ast_print $1
}

toggle_flag() {
  if ${!1}; then
    setvar "$1" false
  else
    setvar "$1" true
  fi
}

read_powscript() {
  IFS="" read -r -e -p "$(format_powscript_prompt "$1")" "$2"
  InteractiveFileLineNumber=$((InteractiveFileLineNumber+1))
}

format_powscript_prompt() {
  local state_name=$1 state

  case $state_name in
    top) state="--" ;;
    double-quotes) state='""' ;;
    single-quotes) state="''" ;;
    *) state="$state_name" ;;

  esac

  local default_prompt='pow[%L]%S> '
  local prompt="${POWSCRIPT_PS1-$default_prompt}"

  prompt="${prompt//%L/$(printf '%.3d' $InteractiveFileLineNumber)}"
  prompt="${prompt//%S/$(printf '%3s'  $state)}"

  echo "$prompt"
}


# FILE: compiler/interactive.bash
# FILE: compiler/compiler.bash

powscript_parse_options "$@"
select_backend $PowscriptBackend

if powscript_is_interactive; then
  interactive_mode
else
  for file in "${PowscriptFiles[@]}"; do
    powscript_compile_file "$PowscriptOutput" <"$file"
  done
fi

${POWSCRIPT_DEBUG-false} || powscript_clean_up
