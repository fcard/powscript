indent_current=0
indent_level=0
stack=()
anonymous_funcs=0

getindent(){
  echo "$1" | sed "s/\n/ /g" | awk '{ match($0, /^ */); printf("%d", RLENGTH) }' | sed 's/00/0/g'
}

add_anonymous_func(){
  anonymous_funcs=$((anonymous_funcs+1))
}

push (){
  local var="$1"
  shift 1
  eval "$var+=($(printf "'%s' " "$@"))";
}

pop (){
  local var="$1"
  eval "
    local index=\$((\${#$var[@]}-1))
    local lastitem=\"\${$var[\$index]}\"
    echo -e \"\$lastitem\"
    unset $var[\$index]
  "
}

stack_push(){
  indent_level=$(($indent_level+2))
  push stack "$1"
}

makeindent(){
  for((i=0;i<$1;i++)); do printf " "; done
}

stack_pop(){
  indent_level=$(($indent_level-2))
  printf "$(makeindent $indent_level)"
  pop stack
}

stack_catchup(){
  local do_continue=false
  while ((indent_current < indent_level)); do
    [[ $index == "-1" ]] && return 0
    if [[ $indent_current == $(($indent_level-2)) ]]; then
      if [[ $1 =~ ^(" "*else) ]]; then
        echo "$1"
        do_continue=true
        break
      elif [[ $1 =~ ^(" "*elif) ]]; then
        transpile_elif "$1"
        do_continue=true
        break
      elif [[ $1 =~ ^(" "*when done) ]]; then
        echo "$(makeindent $indent_current)}"
        transpile_when_done $1
        do_continue=true
        break
      else
        stack_pop $1
      fi
    else
      stack_pop $1
    fi
  done
  $do_continue && continue || true
}

stack_update(){
  indent_current=$(getindent "$1")
  [[ -n $DEBUG ]] && echo ">> $indent_level|$indent_current|stacksize:${#stack[@]}"
  if ((indent_current < indent_level)); then stack_catchup "$1"; fi
}

get_array_code(){
  printf '"'
  printf "\${$1[$2]}"
  printf '"'
}

transpile_all(){
  while IFS="" read -r line; do
    i=$(getindent "$line")
    [[ "$line" =~ ^(#) ]] && local _comment="#"
    [[ "$line" =~ "={}" ]] && echo "$_comment$(makeindent $i)declare -A ${line/=\{\}/}" && continue
    [[ "$line" =~ "=[]" ]] && echo "$_comment$(makeindent $i)declare -a ${line/=\[\]/}" && continue
    [[ "$line" =~ ([ ]\$[A-Za-z_0-9@]) ]] && line="$(echo "$line" | sed -E 's/([ =])\$([a-zA-Z_0-9@]+)/\1"$\2"/gi' )"
    echo "$line"
  done
}

transpile_for(){
  stack_push "done"
  local arr="$(echo "$1" | awk '{ print $4 }' )"
  local i=$(( $(getindent "$code") + 2 ))
  code="$1; do"
  indent="$(makeindent $i)"
  # iterate over associative array
  if [[ "$code" =~ [a-zA-Z_0-9],[a-zA-Z_0-9] ]]; then
    local key="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $1 }')"
    local value="$(echo "$code" | awk '{ print $2 }' | awk -F',' '{ print $2 }')"
    code="$code\n$indent$value=$(get_array_code $arr "\$$key")"
    code="${code/,$value/}"
    code="${code/ of / in }"
    code="${code/ $arr/ $(get_array_code "!$arr" @)}";
  else
    # iterate over indexed array
    local key="$(echo "$code" | awk '{ print $2 }')"
    code="${code/ $arr/ $(get_array_code $arr @)}"
  fi
  echo -e "$code" | transpile_all
}

transpile_while(){
  stack_push "done"
  code="$(transpile_condition while "$1" "$2")"
  code="$code; do"
  echo "$code" | transpile_all
}

transpile_if(){
  stack_push "fi"
  code="$(transpile_condition "if" "$1" "$2")"
  code="$code; then"
  echo "$code" | transpile_all
}

transpile_elif(){
  code="$(transpile_condition "elif" "$1" "$1")"
  code="$code; then"
  echo "$code" | transpile_all
}

transpile_condition(){
  form=$1
  code="${2/$form not/$form !}"
  firstvar="${code/! /}"
  firstvar="$(echo "$firstvar" | awk '{ print $2 }')"
  code="${code// and / && }"
  code="${code// or / || }"
  code="${code//> /-gt }"
  code="${code//>= /-ge }"
  code="${code//< /-lt }"
  code="${code//<= /-le }"
  code="${code//!= /-ne }"
  [[ "$code" =~ ($form[ ]) && "$firstvar" =~ ^([\"\$-]) ]] && code="${code/$form /$form [[ }"
  code="${code/match /=~ }"
  [[ "$code" =~ "[[" ]] && code="$code ]]"
  code="${code// is / == }"
  echo "$code"
}

transpile_then(){
  line="${*/await /}"
  [[ ! -n $3 ]] && category="then" || category="$3"
  add_anonymous_func
  funcindex=$anonymous_funcs
  echo -e "\n# async code"
  echo "_"$category"_$funcindex(){"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  if [[ $category =~ "pipe" ]]; then
    add_anonymous_func
    stack_push "}\n$indent""async_$category _then_when_done_$anonymous_funcs "_"$category"_"$funcindex ${line/ then*/}"
  else
    stack_push "}\n$indent""async_$category "_"$category"_"$funcindex ${line/ then*/}"
  fi
}

transpile_when_done(){
  local curindent=$(getindent "$1")
  echo "_then_when_done_"$anonymous_funcs"(){"
}

transpile_switch(){
  stack_push "esac"
  echo "${1/switch/case} in"
}

transpile_case(){
  stack_push "  ;;"
  echo "${1/case /})"
}

transpile_array_push(){
  code="${1/+=/+=(}"
  echo "$code)"
}

transpile_array_get(){
  code="${1/\$/\"\${}"
  echo "$code}\""
}

transpile_foreachline_from(){
  file="${1/[ ]?for line from /}"
  local curindent=$(getindent "$1")
  local indent="$(makeindent $curindent)"
  echo "$indent""while IFS=\"\" read -r line; do"
  stack_push $indent"done < $file"
}

transpile_function(){
  stack_push "}"
  local curindent=$(( $(getindent "$1") + 2 ))
  local indent="$(makeindent $curindent)"
  fields="${1//*\(/}"
  fields="${fields//\)*/}"
  fields="${fields// /}"
  fields="${fields//,/ }"
  echo "${1//\(*\)/()}{"
  local i=1;
  for field in $fields; do echo "$indent""local $field=\"\$$i\""; i=$((i+1)); done
}
